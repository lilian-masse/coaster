<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Coasters — Fiches</title>

<style>
  :root{--b:#e6e6e6;--bg:#fff;--shadow:0 1px 6px rgba(0,0,0,.04)}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:24px}
  h1{margin:0 0 10px}
  .bar{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:14px;margin-bottom:22px;align-items:start}
  label{font-size:13px;margin-bottom:4px;display:block}
  input,select,button{padding:9px 10px;font-size:14px;width:100%;box-sizing:border-box}
  button{cursor:pointer}

  .box{border:1px solid var(--b);border-radius:12px;padding:10px;background:var(--bg);box-shadow:0 1px 6px rgba(0,0,0,.03)}
  .boxTitle{font-weight:700;font-size:13px;margin:0 0 8px}

  .list{
    max-height:190px;overflow:auto;
    border-top:1px solid #eee;margin-top:8px;padding-top:0;
  }
  .row{display:flex;gap:8px;align-items:center;padding:6px 2px;font-size:13px}
  .row input{width:auto}
  .row small{opacity:.65;margin-left:auto}
  .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .tools button{width:auto;padding:8px 10px;font-size:13px}

  /* ✅ sticky indicator inside scroll zone */
  .stickySel{
    position:sticky;top:0;z-index:5;
    background:#fff;
    border-bottom:1px solid #eee;
    padding:8px 2px;
    font-size:12px;
    opacity:.85;
    display:none;
  }

  .rangeWrap{border:1px solid var(--b);border-radius:12px;padding:10px;background:var(--bg);box-shadow:0 1px 6px rgba(0,0,0,.03)}
  .rangeHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
  .rangeHead .name{font-weight:700;font-size:13px}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #ddd;border-radius:999px;font-size:12px;opacity:.9}

  .dual{position:relative;height:36px}
  .dual input[type="range"]{
    position:absolute;left:0;top:9px;width:100%;
    margin:0;padding:0;background:none;
    pointer-events:none;-webkit-appearance:none;appearance:none;height:18px
  }
  .dual input[type="range"]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:transparent}
  .dual input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;appearance:none;pointer-events:auto;
    height:16px;width:16px;border-radius:50%;
    border:1px solid #999;background:#fff;box-shadow:0 1px 6px rgba(0,0,0,.12);cursor:pointer
  }
  .track{position:absolute;left:0;right:0;top:15px;height:6px;background:#eee;border-radius:999px}
  .fill{position:absolute;top:15px;height:6px;background:#ccc;border-radius:999px}
  .rangeMeta{display:flex;justify-content:space-between;font-size:12px;opacity:.75;margin-top:6px}

  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px}
  .card{border:1px solid var(--b);border-radius:14px;background:#fff;box-shadow:var(--shadow);padding:14px;cursor:pointer}
  .card:focus{outline:2px solid #cfcfcf;outline-offset:2px}
  .title{font-weight:750;margin:0 0 6px;font-size:16px}
  .sub{opacity:.75;margin:0 0 10px;font-size:13px}
  .kv{display:grid;grid-template-columns:130px 1fr;gap:6px 10px;font-size:13px}
  .k{opacity:.6}
  .v{word-break:break-word}

  .empty{padding:18px;border:1px dashed #ccc;border-radius:12px;opacity:.85}
  .error{display:none;white-space:pre-wrap;border:1px solid #f0c2c2;background:#fff5f5;color:#7a1f1f;padding:10px 12px;border-radius:12px;margin:12px 0}

  .modalOverlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:18px;z-index:1000}
  .modalOverlay.open{display:flex}
  .modalWrap{position:relative;width:min(820px, 100%);display:flex;align-items:center;justify-content:center}
  .modal{width:100%;max-height:min(82vh, 820px);overflow:auto;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);border:1px solid #eee}
  .modalHeader{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 16px}
  .modalTitle{font-weight:800;margin:0;font-size:18px;line-height:1.25}
  .modalSub{margin:4px 0 0;opacity:.7;font-size:13px}
  .modalBody{padding:14px 16px 18px}
  .modalGrid{display:grid;grid-template-columns:180px 1fr;gap:8px 12px;font-size:14px}
  .modalK{opacity:.65}
  .modalV{word-break:break-word}
  @media (max-width:560px){ .modalGrid{grid-template-columns:1fr;gap:6px} }

  .navArrow{
    position:absolute;top:50%;transform:translateY(-50%);
    width:46px;height:46px;border-radius:999px;
    border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.28);color:#fff;
    display:flex;align-items:center;justify-content:center;
    cursor:pointer;user-select:none;font-size:26px;line-height:1;padding:0;
  }
  .navArrow:hover{background:rgba(0,0,0,.38)}
  .navArrow:focus{outline:2px solid rgba(255,255,255,.65);outline-offset:2px}
  .navLeft{left:-10px}
  .navRight{right:-10px}
  .navArrow[disabled]{display:none}
  @media (max-width:520px){
    .navLeft{left:4px}.navRight{right:4px}.navArrow{width:42px;height:42px;font-size:24px}
  }

  .sectionTitle{font-weight:800;margin:18px 0 8px;font-size:14px;opacity:.85}
</style>
</head>

<body>
<h1>Coasters</h1>

<div class="bar">
  <div>
    <label>Recherche</label>
    <input id="q" placeholder="Rechercher…">
  </div>

  <div>
    <label>Tri principal</label>
    <select id="sort">
      <option value="park_asc" selected>Parc A→Z</option>
      <option value="year_asc">Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
    </select>
  </div>

  <div>
    <label>Tri secondaire</label>
    <select id="sort2">
      <option value="year_asc" selected>Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
      <option value="park_asc">Parc A→Z</option>
    </select>
  </div>

  <div class="box">
    <div class="boxTitle">Eau ?</div>
    <label class="row" style="padding:0;margin:0;gap:10px">
      <input id="waterOnly" type="checkbox">
      <span>Afficher seulement les coasters “Eau”</span>
      <small id="waterCount">—</small>
    </label>
  </div>

  <div style="align-self:end">
    <button id="clear" type="button">Réinitialiser</button>
  </div>
</div>

<div class="sectionTitle">Filtres</div>
<div class="bar" id="facetBar"></div>

<div class="sectionTitle">Plages numériques</div>
<div class="bar" id="sliderBar"></div>

<div id="err" class="error"></div>
<div id="grid" class="grid"></div>

<div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modalWrap">
    <button id="navLeft" class="navArrow navLeft" type="button" aria-label="Précédent">‹</button>
    <div class="modal" role="document">
      <div class="modalHeader">
        <h2 id="modalTitle" class="modalTitle">—</h2>
        <p id="modalSub" class="modalSub"></p>
        <p class="pill" style="margin:10px 0 0;display:inline-block;opacity:.85">Clique en dehors, Échap, ou flèches ← →</p>
      </div>
      <div class="modalBody">
        <div id="modalGrid" class="modalGrid"></div>
      </div>
    </div>
    <button id="navRight" class="navArrow navRight" type="button" aria-label="Suivant">›</button>
  </div>
</div>

<script>
const dataUrl = "./data/coasters_clean.json";
const $ = (id)=>document.getElementById(id);

function showError(msg){ $("err").style.display="block"; $("err").textContent = msg; }
function clearError(){ $("err").style.display="none"; $("err").textContent = ""; }

function norm(s){
  return String(s ?? "")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\s+/g," ")
    .trim();
}
function esc(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}
function toNumber(v){
  const s = String(v ?? "").trim();
  if(!s) return null;
  const cleaned = s.replace(/[^0-9.\-]/g,"");
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : null;
}
function toInt(v){
  const n = toNumber(v);
  if(n === null) return null;
  return Math.round(n);
}
function toYear(v){
  const n = toNumber(v);
  if(n === null) return null;
  if(n >= 1800 && n <= 2200) return Math.trunc(n);
  const a = Math.abs(n);
  if(a > 1e11){ const y = new Date(n).getUTCFullYear(); return Number.isFinite(y) ? y : null; }
  if(a > 1e9){ const y = new Date(n*1000).getUTCFullYear(); return Number.isFinite(y) ? y : null; }
  return null;
}
function titleizeKey(k){
  const s = String(k ?? "").replace(/_/g," ").trim();
  if(!s) return "Champ";
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function sortFamily(mode){ return String(mode||"").split("_")[0]; }
function pickField(obj, candidates){
  const keys = Object.keys(obj || {});
  const map = new Map(keys.map(k => [norm(k), k]));
  for(const c of candidates){
    const hit = map.get(norm(c));
    if(hit) return hit;
  }
  for(const k of keys){
    const nk = norm(k);
    if(candidates.some(c => nk.includes(norm(c)))) return k;
  }
  return null;
}

/* ---------- Specs ---------- */
const FACET_SPECS = [
  { id:"maker", label:"Fabricant", candidates:["Fabricant","Manufacturer","Constructeur","Builder","Maker"] },
  { id:"park", label:"Parc", candidates:["Parc","Park"] },
  { id:"model", label:"Modèle", candidates:["Modele","Modèle","Model"] },
  { id:"propulsion", label:"Propulsion", candidates:["Propulsion","Launch","Type de propulsion"] },
  { id:"launchAngle", label:"Angle de propulsion", candidates:["Angle de propulsion","Launch angle","Angle propulsion"] },
  { id:"structure", label:"Structure", candidates:["Structure","Structure type"] },
  { id:"particularity", label:"Particularité", candidates:["Particularite","Particularité","Particularity","Spécificité","Specificite"] },
  { id:"rotation", label:"Rotation", candidates:["Rotation","Rotating"] },
  { id:"layout", label:"Disposition", candidates:["Disposition","Layout","Implantation"] },
  { id:"restraint", label:"Sécurité", candidates:["Securite","Sécurité","Restraint","Restraints"] },
];

// ✅ PAS de décimaux => step=1 partout
const NUM_SPECS = [
  { id:"year", label:"Ouverture", candidates:["Ouverture","Année","Annee","Year","Opened","Opening year"], isYear:true, step:1, integer:true },
  { id:"height", label:"Hauteur", candidates:["Hauteur","Height"], step:1, integer:true },
  { id:"speed", label:"Vitesse", candidates:["Vitesse","Speed"], step:1, integer:true },
  { id:"inversions", label:"Inversions", candidates:["Inversions","Inversion"], step:1, integer:true },
  { id:"length", label:"Longueur", candidates:["Longueur","Length"], step:1, integer:true },
  { id:"duration", label:"Durée", candidates:["Duree","Durée","Duration"], step:1, integer:true },
  { id:"capacity", label:"Débit", candidates:["Debit","Débit","Capacity","Throughput"], step:1, integer:true },

  { id:"seatsPerRow", label:"Sièges/rang.", candidates:["Sièges","Sieges","Sieges/rang.","Sièges/rang.","Seats/row","Seats per row","Sieges par rang"], step:1, integer:true },
  { id:"rowsPerCar", label:"Rangées/voit.", candidates:["Rangées","Rangees","Rangees/voit.","Rangées/voit.","Rows/car","Rows per car","Rangees par voiture"], step:1, integer:true },

  { id:"seatsPerCar", label:"Sièges/voit.", candidates:["Sieges/voit.","Sièges/voit.","Seats/car","Seats per car","Sieges par voiture"], step:1, integer:true },
  { id:"carsPerTrain", label:"Voit./train", candidates:["Voit./train","Cars/train","Cars per train","Voitures/train"], step:1, integer:true },
  { id:"seatsPerTrain", label:"Sièges/train", candidates:["Sieges/train","Sièges/train","Seats/train","Seats per train","Sieges par train"], step:1, integer:true },
];

const WATER_CANDIDATES = ["Eau","Water","Splash","Aquatique"];

/* ---------- UI builders ---------- */
function createFacetBox(spec){
  const box = document.createElement("div");
  box.className = "box";
  box.innerHTML = `
    <div class="boxTitle">${esc(spec.label)}</div>
    <input id="search_${spec.id}" placeholder="Filtrer…">
    <div id="list_${spec.id}" class="list"></div>
    <div class="tools">
      <button id="clear_${spec.id}" type="button">Effacer</button>
    </div>
  `;
  return box;
}
function createDualSlider(spec){
  const wrap = document.createElement("div");
  wrap.className = "rangeWrap";
  wrap.innerHTML = `
    <div class="rangeHead">
      <span class="name">${esc(spec.label)}</span>
      <span class="pill" id="pill_${spec.id}">—</span>
    </div>
    <div class="dual">
      <div class="track"></div>
      <div class="fill" id="fill_${spec.id}"></div>
      <input id="${spec.id}_min" type="range" aria-label="${esc(spec.label)} min">
      <input id="${spec.id}_max" type="range" aria-label="${esc(spec.label)} max">
    </div>
    <div class="rangeMeta">
      <span id="lab_${spec.id}_min">—</span>
      <span id="lab_${spec.id}_max">—</span>
    </div>
  `;
  return wrap;
}

/* ---------- Sorting ---------- */
function sortRows(list, mode1, mode2, f){
  const getYear = (r)=> f.year ? (toYear(r[f.year]) ?? null) : null;
  const getPark = (r)=> f.park ? String(r[f.park] ?? "") : "";
  function cmp(mode, a, b){
    if(mode === "year_desc") return (getYear(b) ?? -Infinity) - (getYear(a) ?? -Infinity);
    if(mode === "year_asc")  return (getYear(a) ?? Infinity) - (getYear(b) ?? Infinity);
    if(mode === "park_asc")  return getPark(a).localeCompare(getPark(b), "fr");
    return 0;
  }
  return list.slice().sort((a,b)=>{
    let c = cmp(mode1,a,b); if(c!==0) return c;
    c = cmp(mode2,a,b); if(c!==0) return c;
    c = cmp("park_asc",a,b); if(c!==0) return c;
    return cmp("year_asc",a,b);
  });
}

(async function(){
  clearError();

  const facetBar = $("facetBar");
  const sliderBar = $("sliderBar");
  const grid = $("grid");
  const qEl = $("q");
  const sortSel = $("sort");
  const sort2Sel = $("sort2");
  const waterOnlyEl = $("waterOnly");
  const waterCountEl = $("waterCount");

  const navLeftBtn = $("navLeft");
  const navRightBtn = $("navRight");
  const modalOverlay = $("modalOverlay");
  const modalTitleEl = $("modalTitle");
  const modalSubEl = $("modalSub");
  const modalGridEl = $("modalGrid");

  let allRows = [];
  let fields = {};
  let numFields = {};
  let waterField = null;

  const selected = {};
  const facetUI = {};
  const facetHasScrollListener = {}; // ✅ ensure we bind once
  const sliderUI = {};
  const sliderAbs = {};
  const sliderDyn = {};
  const sliderVal = {};
  const facetMasterOptions = {};

  let waterOnly = false;
  let lastRendered = [];
  let currentIndex = -1;

  function normalizeFacetValue(facetId, raw){
    let v = String(raw ?? "").trim();
    if(facetId === "launchAngle" && !v) return "Incliné";
    if(facetId === "structure" && !v) return "Acier";
    return v;
  }

  function parseWater(row){
    if(waterField){
      const s = norm(row[waterField]);
      if(!s) return false;
      return ["1","true","oui","yes","y","water","eau","splash"].some(t => s === t || s.includes(t));
    }
    const blob = Object.values(row).map(v=>String(v??"")).join(" ").toLowerCase();
    return blob.includes("eau") || blob.includes("water") || blob.includes("splash");
  }

  function computeDerivedSeats(row){
    const aKey = numFields.seatsPerRow;
    const bKey = numFields.rowsPerCar;
    const cKey = numFields.seatsPerCar;
    const dKey = numFields.carsPerTrain;
    const eKey = numFields.seatsPerTrain;

    const a = aKey ? toInt(row[aKey]) : null;
    const b = bKey ? toInt(row[bKey]) : null;
    const c = cKey ? toInt(row[cKey]) : null;
    const d = dKey ? toInt(row[dKey]) : null;
    const e = eKey ? toInt(row[eKey]) : null;

    if(cKey && c === null && a !== null && b !== null) row[cKey] = a * b;

    const cNow = cKey ? toInt(row[cKey]) : null;
    if(eKey && e === null && d !== null && cNow !== null) row[eKey] = cNow * d;
  }

  function clampSwap(minEl, maxEl){
    let a = Number(minEl.value);
    let b = Number(maxEl.value);
    if(a > b){
      const t=a; a=b; b=t;
      minEl.value = String(a);
      maxEl.value = String(b);
    }
    return {min:a, max:b};
  }

  function updateDualUI(id){
    const ui = sliderUI[id];
    const abs = sliderAbs[id];
    if(!ui || !abs || ui.minEl.disabled || ui.maxEl.disabled) return;

    const dyn = sliderDyn[id] || abs;

    ui.minEl.min = String(dyn.min);
    ui.maxEl.min = String(dyn.min);
    ui.minEl.max = String(dyn.max);
    ui.maxEl.max = String(dyn.max);

    let minV = Math.round(Number(ui.minEl.value));
    let maxV = Math.round(Number(ui.maxEl.value));
    minV = Math.max(dyn.min, Math.min(dyn.max, minV));
    maxV = Math.max(dyn.min, Math.min(dyn.max, maxV));
    if(minV > maxV){ const t=minV; minV=maxV; maxV=t; }
    ui.minEl.value = String(minV);
    ui.maxEl.value = String(maxV);

    sliderVal[id] = {min:minV, max:maxV};

    const total = (dyn.max - dyn.min) || 1;
    const left = ((minV - dyn.min) / total) * 100;
    const right = ((maxV - dyn.min) / total) * 100;
    ui.fillEl.style.left = left + "%";
    ui.fillEl.style.width = Math.max(0, right - left) + "%";

    ui.labMin.textContent = String(minV);
    ui.labMax.textContent = String(maxV);
    ui.pill.textContent = `${minV} → ${maxV}`;
  }

  function createFacetUI(){
    facetBar.innerHTML = "";
    for(const spec of FACET_SPECS){
      const box = createFacetBox(spec);
      facetBar.appendChild(box);

      const searchEl = box.querySelector(`#search_${spec.id}`);
      const listEl = box.querySelector(`#list_${spec.id}`);
      const clearBtn = box.querySelector(`#clear_${spec.id}`);

      facetUI[spec.id] = {searchEl, listEl, clearBtn};
      selected[spec.id] = new Set();

      clearBtn.addEventListener("click", ()=>{
        selected[spec.id].clear();
        render();
      });
      searchEl.addEventListener("input", ()=> drawFacetList(spec.id));
    }
  }

  function createSliderUI(){
    sliderBar.innerHTML = "";
    for(const spec of NUM_SPECS){
      const wrap = createDualSlider(spec);
      sliderBar.appendChild(wrap);

      const minEl = wrap.querySelector(`#${spec.id}_min`);
      const maxEl = wrap.querySelector(`#${spec.id}_max`);
      const fillEl = wrap.querySelector(`#fill_${spec.id}`);
      const labMin = wrap.querySelector(`#lab_${spec.id}_min`);
      const labMax = wrap.querySelector(`#lab_${spec.id}_max`);
      const pill = wrap.querySelector(`#pill_${spec.id}`);

      sliderUI[spec.id] = {minEl, maxEl, fillEl, labMin, labMax, pill, spec};

      minEl.addEventListener("input", ()=> onNumericSliderAttempt(spec.id));
      maxEl.addEventListener("input", ()=> onNumericSliderAttempt(spec.id));
    }
  }

  function initSlidersFromData(){
    for(const spec of NUM_SPECS){
      const key = numFields[spec.id];
      const ui = sliderUI[spec.id];

      if(!key){
        ui.minEl.disabled = true;
        ui.maxEl.disabled = true;
        ui.pill.textContent = "— (champ introuvable)";
        ui.labMin.textContent = "—";
        ui.labMax.textContent = "—";
        continue;
      }

      let values = allRows
        .map(r => spec.isYear ? toYear(r[key]) : toInt(r[key]))
        .filter(v => Number.isFinite(v));

      if(values.length === 0){
        ui.minEl.disabled = true;
        ui.maxEl.disabled = true;
        ui.pill.textContent = "— (pas de valeurs)";
        ui.labMin.textContent = "—";
        ui.labMax.textContent = "—";
        continue;
      }

      let min = Math.floor(Math.min(...values));
      let max = Math.ceil(Math.max(...values));

      sliderAbs[spec.id] = {min, max, step:1, integer:true};
      sliderDyn[spec.id] = {min, max};

      ui.minEl.step = "1";
      ui.maxEl.step = "1";

      ui.minEl.value = String(min);
      ui.maxEl.value = String(max);

      updateDualUI(spec.id);
    }
  }

  function passesSearch(row){
    const q = norm(qEl.value);
    if(!q) return true;
    const text = Object.values(row).map(v=>String(v??"")).join(" ").toLowerCase();
    return text.includes(q);
  }
  function passesFacets(row){
    for(const spec of FACET_SPECS){
      const set = selected[spec.id];
      if(!set || set.size === 0) continue;
      const key = fields[spec.id];
      const v = normalizeFacetValue(spec.id, row[key]);
      if(!set.has(v)) return false;
    }
    return true;
  }
  function passesSliders(row){
    for(const spec of NUM_SPECS){
      const key = numFields[spec.id];
      const ui = sliderUI[spec.id];
      if(!key || !ui || ui.minEl.disabled) continue;

      const {min, max} = sliderVal[spec.id] || sliderAbs[spec.id];
      const val = spec.isYear ? toYear(row[key]) : toInt(row[key]);

      if(val === null){
        const abs = sliderAbs[spec.id];
        if(min !== abs.min || max !== abs.max) return false;
      } else {
        if(val < min || val > max) return false;
      }
    }
    return true;
  }
  function passesWater(row){
    if(!waterOnly) return true;
    return !!row.__water;
  }
  function passesAll(row){
    const n = String(row[fields.name] ?? "").trim();
    if(!n) return false;
    return passesSearch(row) && passesSliders(row) && passesFacets(row) && passesWater(row);
  }

  function baseRowsExcludingFacet(excludeFacetId){
    return allRows.filter(r=>{
      const n = String(r[fields.name] ?? "").trim();
      if(!n) return false;
      if(!passesSearch(r)) return false;
      if(!passesSliders(r)) return false;
      if(!passesWater(r)) return false;

      for(const spec of FACET_SPECS){
        if(spec.id === excludeFacetId) continue;
        const set = selected[spec.id];
        if(set && set.size){
          const key = fields[spec.id];
          const v = normalizeFacetValue(spec.id, r[key]);
          if(!set.has(v)) return false;
        }
      }
      return true;
    });
  }

  function computeFacetCounts(facetId){
    const key = fields[facetId];
    if(!key) return new Map();
    const base = baseRowsExcludingFacet(facetId);
    const m = new Map();
    for(const r of base){
      const v = normalizeFacetValue(facetId, r[key]);
      if(!v) continue;
      m.set(v, (m.get(v) || 0) + 1);
    }
    return m;
  }

  function computeWaterCount(){
    const base = allRows.filter(r=>{
      const n = String(r[fields.name] ?? "").trim();
      if(!n) return false;
      if(!passesSearch(r)) return false;
      if(!passesSliders(r)) return false;
      if(!passesFacets(r)) return false;
      return true;
    });
    let c = 0;
    for(const r of base) if(r.__water) c++;
    return c;
  }

  // ✅ Default: strictly count desc, tie => alpha
  function sortOptionsDefault(options, counts){
    return options.slice().sort((a,b)=>{
      const ca = counts.get(a) || 0;
      const cb = counts.get(b) || 0;
      if(cb !== ca) return cb - ca;
      return String(a).localeCompare(String(b), "fr");
    });
  }

  // ✅ When not default (search OR selection): selected first, then count desc, then alpha
  function sortOptionsSelectedFirst(options, counts, selectedSet){
    return options.slice().sort((a,b)=>{
      const sa = selectedSet.has(a) ? 1 : 0;
      const sb = selectedSet.has(b) ? 1 : 0;
      if(sb !== sa) return sb - sa;
      const ca = counts.get(a) || 0;
      const cb = counts.get(b) || 0;
      if(cb !== ca) return cb - ca;
      return String(a).localeCompare(String(b), "fr");
    });
  }

  // ✅ Sticky indicator: show "X sélectionné(s)" if some selected not visible in scroll
  function updateStickySelectionIndicator(facetId){
    const ui = facetUI[facetId];
    if(!ui) return;
    const listEl = ui.listEl;
    const sticky = listEl.querySelector(`#sticky_${facetId}`);
    if(!sticky) return;

    const set = selected[facetId];
    const selectedCount = set ? set.size : 0;

    if(selectedCount === 0){
      sticky.style.display = "none";
      sticky.textContent = "";
      return;
    }

    // measure visibility
    const top = listEl.scrollTop;
    const bottom = top + listEl.clientHeight;

    const selectedRows = Array.from(listEl.querySelectorAll('label.row input[type="checkbox"]:checked'))
      .map(cb => cb.closest("label.row"))
      .filter(Boolean);

    if(selectedRows.length === 0){
      sticky.style.display = "none";
      sticky.textContent = "";
      return;
    }

    let anyHidden = false;
    for(const row of selectedRows){
      const rowTop = row.offsetTop;
      const rowBottom = rowTop + row.offsetHeight;
      if(rowBottom < top || rowTop > bottom){
        anyHidden = true;
        break;
      }
    }

    if(anyHidden){
      sticky.textContent = `${selectedCount} sélectionné${selectedCount>1 ? "s" : ""}`;
      sticky.style.display = "block";
    } else {
      sticky.style.display = "none";
      sticky.textContent = "";
    }
  }

  function drawFacetList(facetId){
    const ui = facetUI[facetId];
    const key = fields[facetId];

    if(!key){
      ui.listEl.innerHTML = `<div class="empty">Champ introuvable</div>`;
      ui.searchEl.disabled = true;
      return;
    }

    const searchText = norm(ui.searchEl.value);
    const selectedSet = selected[facetId];
    const counts = computeFacetCounts(facetId);

    const baseOptions = facetMasterOptions[facetId] || [];
    const optSet = new Set([...baseOptions, ...Array.from(selectedSet)]);
    let options = Array.from(optSet).filter(v => v && !["-", "—", "n/a", "na", "unknown"].includes(norm(v)));

    // ✅ requested behavior:
    // - if "tout est par défaut" for this facet (no selection + no facet-search): pure count desc
    // - otherwise: selected first + count desc
    const isFacetDefault = (selectedSet.size === 0 && !searchText);
    options = isFacetDefault
      ? sortOptionsDefault(options, counts)
      : sortOptionsSelectedFirst(options, counts, selectedSet);

    const shown = options.filter(v => norm(v).includes(searchText));

    // ✅ sticky header is inside scroll zone
    ui.listEl.innerHTML =
      `<div class="stickySel" id="sticky_${facetId}"></div>` +
      (shown.map(v=>{
        const c = counts.get(v) || 0; // show 0
        const disabled = (c === 0 && !selectedSet.has(v)) ? "disabled" : "";
        const checked = selectedSet.has(v) ? "checked" : "";
        return `
          <label class="row">
            <input type="checkbox" value="${esc(v)}" ${checked} ${disabled}>
            <span>${esc(v)}</span>
            <small>${c}</small>
          </label>
        `;
      }).join("") || `<div class="empty">Aucune option</div>`);

    ui.listEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const v = cb.value;
        if(cb.checked) selectedSet.add(v);
        else selectedSet.delete(v);
        render();
      });
    });

    // bind scroll listener once
    if(!facetHasScrollListener[facetId]){
      facetHasScrollListener[facetId] = true;
      ui.listEl.addEventListener("scroll", ()=> updateStickySelectionIndicator(facetId));
    }

    // update sticky now (after DOM update)
    updateStickySelectionIndicator(facetId);
  }

  function updateAllFacetUIs(){
    for(const spec of FACET_SPECS) drawFacetList(spec.id);

    const c = computeWaterCount();
    waterCountEl.textContent = String(c);
    waterOnlyEl.disabled = (c === 0 && !waterOnly);
  }

  function getRange(id){
    const abs = sliderAbs[id];
    const ui = sliderUI[id];
    if(!abs || !ui || ui.minEl.disabled) return null;
    const {min, max} = sliderVal[id] || abs;
    return {min:Number(min), max:Number(max)};
  }
  function setDyn(id, dynMin, dynMax){
    const abs = sliderAbs[id];
    if(!abs) return;
    const dmin = Math.max(abs.min, Math.min(abs.max, Math.round(dynMin)));
    const dmax = Math.max(abs.min, Math.min(abs.max, Math.round(dynMax)));
    sliderDyn[id] = {min: Math.min(dmin,dmax), max: Math.max(dmin,dmax)};
  }

  function enforceSeatConstraints(){
    const A = getRange("seatsPerRow");
    const B = getRange("rowsPerCar");
    const C = getRange("seatsPerCar");
    if(A && B && C){
      const cmin = Math.max(1, Math.floor(C.min));
      const cmax = Math.max(1, Math.floor(C.max));
      const amin = Math.max(1, Math.floor(A.min));
      const amax = Math.max(1, Math.floor(A.max));
      const bmin = Math.max(1, Math.floor(B.min));
      const bmax = Math.max(1, Math.floor(B.max));

      setDyn("seatsPerRow", Math.ceil(cmin / Math.max(1, bmax)), Math.floor(cmax / Math.max(1, bmin)));
      setDyn("rowsPerCar", Math.ceil(cmin / Math.max(1, amax)), Math.floor(cmax / Math.max(1, amin)));
      setDyn("seatsPerCar", amin * bmin, amax * bmax);

      updateDualUI("seatsPerRow");
      updateDualUI("rowsPerCar");
      updateDualUI("seatsPerCar");
    }

    const C2 = getRange("seatsPerCar");
    const D = getRange("carsPerTrain");
    const E = getRange("seatsPerTrain");
    if(C2 && D && E){
      const emin = Math.max(1, Math.floor(E.min));
      const emax = Math.max(1, Math.floor(E.max));
      const cmin2 = Math.max(1, Math.floor(C2.min));
      const cmax2 = Math.max(1, Math.floor(C2.max));
      const dmin = Math.max(1, Math.floor(D.min));
      const dmax = Math.max(1, Math.floor(D.max));

      const C_low2 = Math.ceil(emin / Math.max(1, dmax));
      const C_high2 = Math.floor(emax / Math.max(1, dmin));
      const cur = sliderDyn["seatsPerCar"] || sliderAbs["seatsPerCar"];
      setDyn("seatsPerCar", Math.max(cur.min, C_low2), Math.min(cur.max, C_high2));

      setDyn("carsPerTrain", Math.ceil(emin / Math.max(1, cmax2)), Math.floor(emax / Math.max(1, cmin2)));
      setDyn("seatsPerTrain", cmin2 * dmin, cmax2 * dmax);

      updateDualUI("seatsPerCar");
      updateDualUI("carsPerTrain");
      updateDualUI("seatsPerTrain");
    }
  }

  function cardHTML(r, idx){
    const name = String(r[fields.name] ?? "").trim();
    const park = fields.park ? String(r[fields.park] ?? "").trim() : "";
    const y = numFields.year ? toYear(r[numFields.year]) : null;

    const rows = [];
    if(fields.maker) rows.push(["Fabricant", r[fields.maker]]);
    if(numFields.year) rows.push(["Ouverture", (y ?? "")]);

    const kv = rows
      .filter(([_,v]) => String(v ?? "").trim() !== "")
      .map(([k,v]) => `<div class="k">${esc(k)}</div><div class="v">${esc(v)}</div>`)
      .join("");

    return `
      <article class="card" tabindex="0" role="button" aria-label="Ouvrir les détails" data-idx="${idx}">
        <h2 class="title">${esc(name)}</h2>
        ${park ? `<p class="sub">${esc(park)}</p>` : ""}
        <div class="kv">${kv || `<div class="empty">Aucune info</div>`}</div>
      </article>
    `;
  }

  function updateArrowsState(){
    const n = lastRendered.length;
    if(n <= 1){ navLeftBtn.disabled = true; navRightBtn.disabled = true; return; }
    navLeftBtn.disabled = (currentIndex <= 0);
    navRightBtn.disabled = (currentIndex >= n - 1);
  }

  function openModalAtIndex(idx){
    const n = lastRendered.length;
    if(!n) return;
    currentIndex = Math.max(0, Math.min(n-1, idx));
    const row = lastRendered[currentIndex];

    const name = String(row[fields.name] ?? "").trim();
    const park  = fields.park ? String(row[fields.park] ?? "").trim() : "";

    modalTitleEl.textContent = name || "—";
    modalSubEl.textContent = park || "";

    const excludeKeys = new Set([fields.name, fields.park]);
    const pairs = Object.entries(row)
      .filter(([k,v]) => !excludeKeys.has(k) && !String(k).startsWith("__") && String(v ?? "").trim() !== "")
      .map(([k,v]) => {
        if(numFields.year && k === numFields.year){
          const yy = toYear(v);
          return [titleizeKey(k), (yy ?? v)];
        }
        return [titleizeKey(k), v];
      });

    modalGridEl.innerHTML = pairs.map(([k,v]) =>
      `<div class="modalK">${esc(k)}</div><div class="modalV">${esc(v)}</div>`
    ).join("") || `<div class="empty">Aucun détail.</div>`;

    updateArrowsState();
    modalOverlay.classList.add("open");
    modalOverlay.setAttribute("aria-hidden","false");
  }

  function closeModal(){
    modalOverlay.classList.remove("open");
    modalOverlay.setAttribute("aria-hidden","true");
    currentIndex = -1;
  }
  function prevModal(){ if(!navLeftBtn.disabled) openModalAtIndex(currentIndex - 1); }
  function nextModal(){ if(!navRightBtn.disabled) openModalAtIndex(currentIndex + 1); }

  navLeftBtn.addEventListener("click",(e)=>{e.stopPropagation();prevModal();});
  navRightBtn.addEventListener("click",(e)=>{e.stopPropagation();nextModal();});
  modalOverlay.addEventListener("click",(e)=>{ if(e.target===modalOverlay) closeModal(); });
  document.addEventListener("keydown",(e)=>{
    if(!modalOverlay.classList.contains("open")) return;
    if(e.key==="Escape"){ closeModal(); return; }
    if(e.key==="ArrowLeft"){ e.preventDefault(); prevModal(); return; }
    if(e.key==="ArrowRight"){ e.preventDefault(); nextModal(); return; }
  });

  // Numeric sliders must never lead to 0 results
  const lastGoodSliderValue = {};

  function countResults(){
    let c = 0;
    for(const r of allRows) if(passesAll(r)) c++;
    return c;
  }
  function snapshotSlider(id){
    const ui = sliderUI[id];
    if(!ui || ui.minEl.disabled) return null;
    return {min:Number(ui.minEl.value), max:Number(ui.maxEl.value)};
  }
  function restoreSlider(id, snap){
    if(!snap) return;
    const ui = sliderUI[id];
    if(!ui || ui.minEl.disabled) return;
    ui.minEl.value = String(Math.round(snap.min));
    ui.maxEl.value = String(Math.round(snap.max));
    updateDualUI(id);
  }
  function onNumericSliderAttempt(id){
    const ui = sliderUI[id];
    const abs = sliderAbs[id];
    if(!ui || !abs || ui.minEl.disabled) return;

    ui.minEl.value = String(Math.round(Number(ui.minEl.value)));
    ui.maxEl.value = String(Math.round(Number(ui.maxEl.value)));
    clampSwap(ui.minEl, ui.maxEl);

    updateDualUI(id);
    enforceSeatConstraints();

    const n = countResults();
    if(n === 0){
      restoreSlider(id, lastGoodSliderValue[id] || {min:abs.min, max:abs.max});
      enforceSeatConstraints();
      render();
      return;
    }
    lastGoodSliderValue[id] = snapshotSlider(id) || {min:abs.min, max:abs.max};
    render();
  }

  function render(){
    const fam1 = sortFamily(sortSel.value);
    for(const opt of Array.from(sort2Sel.options)){
      opt.disabled = (sortFamily(opt.value) === fam1);
    }
    if(sortFamily(sort2Sel.value) === fam1){
      const firstValid = Array.from(sort2Sel.options).find(o => !o.disabled);
      if(firstValid) sort2Sel.value = firstValid.value;
    }

    waterOnly = !!waterOnlyEl.checked;

    for(const spec of NUM_SPECS){
      const ui = sliderUI[spec.id];
      if(ui && sliderAbs[spec.id] && !ui.minEl.disabled) updateDualUI(spec.id);
    }
    enforceSeatConstraints();

    let filtered = allRows.filter(passesAll);
    filtered = sortRows(filtered, sortSel.value, sort2Sel.value, {year:numFields.year, park:fields.park});
    lastRendered = filtered;

    if(filtered.length === 0){
      grid.innerHTML = `<div class="empty">Aucun résultat.</div>`;
    } else {
      grid.innerHTML = filtered.map((r,i)=>cardHTML(r,i)).join("");
      grid.querySelectorAll(".card").forEach(card=>{
        const idx = Number(card.getAttribute("data-idx"));
        card.addEventListener("click", ()=> openModalAtIndex(idx));
        card.addEventListener("keydown",(e)=>{
          if(e.key==="Enter" || e.key===" "){
            e.preventDefault();
            openModalAtIndex(idx);
          }
        });
      });
    }

    updateAllFacetUIs(); // will refresh counts + sticky indicator

    if(modalOverlay.classList.contains("open")){
      if(lastRendered.length === 0){ closeModal(); return; }
      if(currentIndex >= lastRendered.length) currentIndex = lastRendered.length - 1;
      updateArrowsState();
    }
  }

  try{
    const res = await fetch(dataUrl, { cache:"no-store" });
    if(!res.ok) throw new Error(`Fetch échoué (${res.status}) sur ${dataUrl}`);
    const rows = await res.json();
    if(!Array.isArray(rows)) throw new Error("Le JSON doit être un tableau.");
    if(rows.length === 0){ grid.innerHTML = `<div class="empty">Aucune donnée.</div>`; return; }

    const sample = rows[0];

    fields.name = pickField(sample, ["Nom","Name","Coaster","Attraction","Ride"]);
    if(!fields.name) throw new Error("Champ 'Nom de coaster' introuvable (Nom/Name/Coaster…).");

    for(const spec of FACET_SPECS) fields[spec.id] = pickField(sample, spec.candidates);
    for(const spec of NUM_SPECS) numFields[spec.id] = pickField(sample, spec.candidates);
    waterField = pickField(sample, WATER_CANDIDATES);

    createFacetUI();
    createSliderUI();

    allRows = rows.map(r=>{
      const rr = {...r};
      rr.__water = parseWater(rr);
      computeDerivedSeats(rr);
      return rr;
    });

    // master options for showing 0 counts
    for(const spec of FACET_SPECS){
      const key = fields[spec.id];
      if(!key){ facetMasterOptions[spec.id] = []; continue; }
      const opts = allRows
        .map(r => normalizeFacetValue(spec.id, r[key]))
        .filter(v => v && !["-", "—", "n/a", "na", "unknown"].includes(norm(v)));
      facetMasterOptions[spec.id] = Array.from(new Set(opts)).sort((a,b)=>String(a).localeCompare(String(b), "fr"));
    }

    initSlidersFromData();
    enforceSeatConstraints();

    // full span at load + lastGood = full span
    for(const spec of NUM_SPECS){
      const abs = sliderAbs[spec.id];
      const ui = sliderUI[spec.id];
      if(!abs || !ui || ui.minEl.disabled) continue;
      sliderDyn[spec.id] = {min:abs.min, max:abs.max};
      ui.minEl.value = String(abs.min);
      ui.maxEl.value = String(abs.max);
      updateDualUI(spec.id);
      lastGoodSliderValue[spec.id] = {min:abs.min, max:abs.max};
    }
    enforceSeatConstraints();

    qEl.addEventListener("input", render);

    let prevPrimary = sortSel.value;
    sortSel.addEventListener("change", ()=>{
      const newPrimary = sortSel.value;
      if(sortFamily(newPrimary) === sortFamily(sort2Sel.value)){
        sort2Sel.value = prevPrimary;
      }
      prevPrimary = newPrimary;
      render();
    });
    sort2Sel.addEventListener("change", render);

    waterOnlyEl.addEventListener("change", render);

    $("clear").addEventListener("click", ()=>{
      qEl.value = "";
      waterOnlyEl.checked = false;

      for(const spec of FACET_SPECS){
        selected[spec.id].clear();
        facetUI[spec.id].searchEl.value = "";
      }

      for(const spec of NUM_SPECS){
        const abs = sliderAbs[spec.id];
        const ui = sliderUI[spec.id];
        if(!abs || !ui || ui.minEl.disabled) continue;
        sliderDyn[spec.id] = {min:abs.min, max:abs.max};
        ui.minEl.value = String(abs.min);
        ui.maxEl.value = String(abs.max);
        updateDualUI(spec.id);
        lastGoodSliderValue[spec.id] = {min:abs.min, max:abs.max};
      }
      enforceSeatConstraints();

      sortSel.value = "park_asc";
      sort2Sel.value = "year_asc";
      prevPrimary = sortSel.value;

      closeModal();
      render();
    });

    render();

  } catch(e){
    console.error(e);
    showError(
      "Erreur:\n" + (e?.message ?? String(e)) +
      "\n\nÀ vérifier:\n- data/coasters_clean.json existe\n- JSON valide (tableau)\n- GitHub Pages (pas file://)"
    );
  }
})();
</script>
</body>
</html>

<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Coasters — Fiches</title>

<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:24px}
  h1{margin:0 0 10px}
  .bar{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:14px;margin-bottom:22px;align-items:start}
  label{font-size:13px;margin-bottom:4px;display:block}
  input,select,button{padding:9px 10px;font-size:14px;width:100%;box-sizing:border-box}
  button{cursor:pointer}

  .multibox{border:1px solid #e6e6e6;border-radius:12px;padding:10px;background:#fff;box-shadow:0 1px 6px rgba(0,0,0,.03)}
  .multibox .list{max-height:190px;overflow:auto;border-top:1px solid #eee;margin-top:8px;padding-top:8px}
  .multibox .row{display:flex;gap:8px;align-items:center;padding:6px 2px;font-size:13px}
  .multibox .row input{width:auto}
  .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .tools button{width:auto;padding:8px 10px;font-size:13px}

  .range-wrap{position:relative;height:36px}
  .range-wrap input[type="range"]{
    position:absolute;left:0;top:9px;width:100%;
    margin:0;padding:0;background:none;
    pointer-events:none;-webkit-appearance:none;appearance:none;height:18px
  }
  .range-wrap input[type="range"]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:transparent}
  .range-wrap input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;appearance:none;pointer-events:auto;
    height:16px;width:16px;border-radius:50%;
    border:1px solid #999;background:#fff;box-shadow:0 1px 6px rgba(0,0,0,.12);cursor:pointer
  }
  .track{position:absolute;left:0;right:0;top:15px;height:6px;background:#eee;border-radius:999px}
  .range{position:absolute;top:15px;height:6px;background:#ccc;border-radius:999px}
  .range-meta{display:flex;justify-content:space-between;font-size:12px;opacity:.75;margin-top:6px}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #ddd;border-radius:999px;font-size:12px}

  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px}

  /* Card */
  .card{
    border:1px solid #e6e6e6;border-radius:14px;background:#fff;
    box-shadow:0 1px 6px rgba(0,0,0,.04);
    overflow:hidden;
  }
  .cardBtn{
    width:100%;
    text-align:left;
    border:0;
    background:transparent;
    padding:14px;
    cursor:pointer;
  }
  .title{font-weight:750;margin:0 0 6px;font-size:16px}
  .sub{opacity:.75;margin:0 0 10px;font-size:13px}
  .kv{display:grid;grid-template-columns:110px 1fr;gap:6px 10px;font-size:13px}
  .k{opacity:.6}
  .v{word-break:break-word}

  .details{
    border-top:1px solid #eee;
    padding:12px 14px 14px;
    display:none;
  }
  .card.open .details{display:block}
  .detailsTitle{
    display:flex;justify-content:space-between;align-items:center;
    margin:0 0 10px;font-size:13px;opacity:.8
  }

  .empty{padding:18px;border:1px dashed #ccc;border-radius:12px;opacity:.85}
  .error{display:none;white-space:pre-wrap;border:1px solid #f0c2c2;background:#fff5f5;color:#7a1f1f;padding:10px 12px;border-radius:12px;margin:12px 0}
</style>
</head>

<body>
<h1>Coasters</h1>

<div class="bar">
  <div>
    <label>Recherche</label>
    <input id="q" placeholder="Rechercher…">
  </div>

  <div>
    <label>Fabricants</label>
    <div class="multibox" id="makerBox">
      <input id="makerSearch" placeholder="Filtrer fabricant…">
      <div id="makerList" class="list"></div>
      <div class="tools">
        <button id="makerClear" type="button">Effacer</button>
      </div>
    </div>
  </div>

  <div>
    <label>Parcs</label>
    <div class="multibox" id="parkBox">
      <input id="parkSearch" placeholder="Filtrer parc…">
      <div id="parkList" class="list"></div>
      <div class="tools">
        <button id="parkClear" type="button">Effacer</button>
      </div>
    </div>
  </div>

  <div>
    <label>Ouverture</label>
    <div class="range-wrap">
      <div class="track"></div>
      <div id="rangeFill" class="range"></div>
      <input id="yearMin" type="range" aria-label="Année minimum">
      <input id="yearMax" type="range" aria-label="Année maximum">
    </div>
    <div class="range-meta">
      <span class="pill" id="minLabel">—</span>
      <span class="pill" id="maxLabel">—</span>
    </div>
  </div>

  <div>
    <label>Tri principal</label>
    <select id="sort">
      <option value="park_asc" selected>Parc A→Z</option>
      <option value="year_asc">Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
    </select>
  </div>

  <div>
    <label>Tri secondaire</label>
    <select id="sort2">
      <option value="year_asc" selected>Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
      <option value="park_asc">Parc A→Z</option>
    </select>
  </div>

  <div style="align-self:end">
    <button id="clear" type="button">Réinitialiser</button>
  </div>
</div>

<div id="err" class="error"></div>
<div id="grid" class="grid"></div>

<script>
const dataUrl = "./data/coasters_clean.json";

/* --- DOM --- */
const qEl = document.getElementById("q");
const sortSel = document.getElementById("sort");
const sort2Sel = document.getElementById("sort2");

const makerBox = document.getElementById("makerBox");
const parkBox  = document.getElementById("parkBox");
const makerList = document.getElementById("makerList");
const parkList  = document.getElementById("parkList");
const makerSearch = document.getElementById("makerSearch");
const parkSearch  = document.getElementById("parkSearch");

const grid = document.getElementById("grid");
const errBox = document.getElementById("err");

const yearMinEl = document.getElementById("yearMin");
const yearMaxEl = document.getElementById("yearMax");
const fill = document.getElementById("rangeFill");
const minLabel = document.getElementById("minLabel");
const maxLabel = document.getElementById("maxLabel");

function showError(msg){ errBox.style.display="block"; errBox.textContent = msg; }
function clearError(){ errBox.style.display="none"; errBox.textContent = ""; }

function norm(v){ return String(v ?? "").trim().toLowerCase(); }
function esc(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}

function pickField(obj, candidates){
  const keys = Object.keys(obj || {});
  const lower = new Map(keys.map(k => [k.toLowerCase(), k]));
  for(const c of candidates){
    const hit = lower.get(String(c).toLowerCase());
    if(hit) return hit;
  }
  // fallback: contient le mot
  for(const k of keys){
    const kl = k.toLowerCase();
    if(candidates.some(c => kl.includes(String(c).toLowerCase()))) return k;
  }
  return null;
}

function toNumber(v){
  const s = String(v ?? "").trim();
  if(!s) return null;
  const cleaned = s.replace(/[^0-9.\-]/g,"");
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : null;
}

// ✅ timestamps positifs & négatifs (avant 1970)
function toYear(v){
  const n = toNumber(v);
  if(n === null) return null;

  if(n >= 1800 && n <= 2200) return Math.trunc(n);

  const a = Math.abs(n);
  if(a > 1e11){
    const y = new Date(n).getUTCFullYear();
    return Number.isFinite(y) ? y : null;
  }
  if(a > 1e9){
    const y = new Date(n * 1000).getUTCFullYear();
    return Number.isFinite(y) ? y : null;
  }
  return null;
}

function sortFamily(mode){
  return String(mode || "").split("_")[0]; // "park" ou "year"
}

function clampSwap(){
  let a = parseInt(yearMinEl.value, 10);
  let b = parseInt(yearMaxEl.value, 10);
  if(a > b){
    const t = a; a = b; b = t;
    yearMinEl.value = String(a);
    yearMaxEl.value = String(b);
  }
  return {min:a, max:b};
}

function updateSliderUI(absMin, absMax){
  const {min, max} = clampSwap();
  minLabel.textContent = String(min);
  maxLabel.textContent = String(max);

  const total = (absMax - absMin) || 1;
  const left = ((min - absMin) / total) * 100;
  const right = ((max - absMin) / total) * 100;

  fill.style.left = left + "%";
  fill.style.width = Math.max(0, right - left) + "%";
  return {min, max};
}

function uniqueSorted(values){
  const cleaned = values
    .map(v => String(v ?? "").trim())
    .filter(v => v !== "" && v.toLowerCase() !== "unknown" && v !== "-" && v !== "—" && v.toLowerCase() !== "n/a");
  return Array.from(new Set(cleaned)).sort((a,b)=>a.localeCompare(b,"fr"));
}

function matchesQuery(row, q){
  if(!q) return true;
  const text = Object.values(row).map(v=>String(v??"")).join(" ").toLowerCase();
  return text.includes(q);
}

function hasCoasterName(row, nameField){
  if(!nameField) return false;
  const n = String(row[nameField] ?? "").trim().toLowerCase();
  if(!n) return false;
  if(n === "n/a" || n === "na" || n === "unknown" || n === "-" || n === "—") return false;
  return true;
}

function sortRows(list, mode1, mode2, f){
  const getYear = (r) => f.year ? (toYear(r[f.year]) ?? null) : null;
  const getPark = (r) => f.park ? String(r[f.park] ?? "") : "";

  function cmp(mode, a, b){
    if(mode === "year_desc") return (getYear(b) ?? -Infinity) - (getYear(a) ?? -Infinity);
    if(mode === "year_asc")  return (getYear(a) ?? Infinity) - (getYear(b) ?? Infinity);
    if(mode === "park_asc")  return getPark(a).localeCompare(getPark(b), "fr");
    return 0;
  }

  return list.slice().sort((a,b)=>{
    let c = cmp(mode1, a, b);
    if(c !== 0) return c;
    c = cmp(mode2, a, b);
    if(c !== 0) return c;
    c = cmp("park_asc", a, b);
    if(c !== 0) return c;
    return cmp("year_asc", a, b);
  });
}

function titleizeKey(k){
  const s = String(k ?? "").replace(/_/g," ").trim();
  if(!s) return "Champ";
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/* --- Checklist renderer --- */
function drawChecklist(containerEl, labels, selectedSet, searchEl, onChange){
  function draw(){
    const ft = norm(searchEl.value);
    const shown = labels.filter(l => norm(l).includes(ft));

    containerEl.innerHTML = shown.map(label => {
      const checked = selectedSet.has(label) ? "checked" : "";
      return `
        <div class="row">
          <input type="checkbox" value="${esc(label)}" ${checked}>
          <span>${esc(label)}</span>
        </div>
      `;
    }).join("");

    containerEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const v = cb.value;
        if(cb.checked) selectedSet.add(v);
        else selectedSet.delete(v);
        onChange();
      });
    });
  }

  searchEl.addEventListener("input", draw);
  draw();

  return {
    clear: () => { selectedSet.clear(); searchEl.value=""; draw(); },
    redraw: draw
  };
}

/* --- Card with click-to-expand --- */
function cardHTML(r, f, idx, expanded){
  const title = String(r[f.name] ?? "").trim();
  const park = f.park ? String(r[f.park] ?? "").trim() : "";
  const y = f.year ? toYear(r[f.year]) : null;

  // compact (toujours visible)
  const compactRows = [];
  if(f.maker) compactRows.push(["Fabricant", r[f.maker]]);
  if(f.year)  compactRows.push(["Ouverture", (y ?? "")]);

  const compactKV = compactRows
    .filter(([_,v]) => String(v ?? "").trim() !== "")
    .map(([k,v]) => `<div class="k">${esc(k)}</div><div class="v">${esc(v)}</div>`)
    .join("");

  // details : toutes les colonnes non vides, en évitant doublons (nom/parc)
  const excludeKeys = new Set([f.name, f.park]); // parc en sous-titre uniquement
  const detailPairs = Object.entries(r)
    .filter(([k,v]) => !excludeKeys.has(k) && String(v ?? "").trim() !== "")
    .map(([k,v]) => {
      // si c'est l'année: afficher l'année
      if(f.year && k === f.year){
        const yy = toYear(v);
        return [titleizeKey(k), (yy ?? v)];
      }
      return [titleizeKey(k), v];
    });

  const detailKV = detailPairs.map(([k,v]) =>
    `<div class="k">${esc(k)}</div><div class="v">${esc(v)}</div>`
  ).join("");

  const openClass = expanded ? "open" : "";
  const ariaExpanded = expanded ? "true" : "false";

  return `
    <article class="card ${openClass}" data-idx="${idx}">
      <button class="cardBtn" type="button" aria-expanded="${ariaExpanded}">
        <h2 class="title">${esc(title)}</h2>
        ${park ? `<p class="sub">${esc(park)}</p>` : ""}
        <div class="kv">${compactKV || `<div class="empty">Aucune info</div>`}</div>
      </button>
      <div class="details">
        <div class="detailsTitle">
          <span>Détails</span>
          <span class="pill">clic pour replier</span>
        </div>
        <div class="kv">
          ${detailKV || `<div class="empty">Aucun détail.</div>`}
        </div>
      </div>
    </article>
  `;
}

(async function init(){
  clearError();

  try{
    const res = await fetch(dataUrl, { cache:"no-store" });
    if(!res.ok) throw new Error(`Fetch échoué (${res.status}) sur ${dataUrl}`);

    const rows = await res.json();
    if(!Array.isArray(rows)) throw new Error("Le JSON doit être un tableau.");
    if(rows.length === 0){ grid.innerHTML = `<div class="empty">Aucune donnée.</div>`; return; }

    const sample = rows[0];

    const f = {
      name: pickField(sample, ["Nom","Name","Coaster","coaster","ride","attraction"]),
      park: pickField(sample, ["Parc","Park","parc","park"]),
      maker: pickField(sample, ["Fabricant","Manufacturer","Constructeur","maker","builder"]),
      year: pickField(sample, ["Ouverture","Année","Annee","Year","opened","opening_year"]),
    };

    if(!f.name){
      throw new Error("Champ 'Nom de coaster' introuvable. Vérifie la clé (Nom/Name/Coaster…).");
    }
    if(!f.maker){
      makerBox.innerHTML = `<div class="empty">Champ "Fabricant" non trouvé.</div>`;
    }
    if(!f.park){
      parkBox.innerHTML = `<div class="empty">Champ "Parc" non trouvé.</div>`;
    }

    // plage année globale
    let absMin = 1900, absMax = new Date().getUTCFullYear();
    if(f.year){
      const years = rows.map(r => toYear(r[f.year])).filter(y => Number.isFinite(y));
      if(years.length){ absMin = Math.min(...years); absMax = Math.max(...years); }
    }

    yearMinEl.min = yearMaxEl.min = String(absMin);
    yearMinEl.max = yearMaxEl.max = String(absMax);
    yearMinEl.value = String(absMin);
    yearMaxEl.value = String(absMax);

    const selectedMakers = new Set();
    const selectedParks  = new Set();

    const makerLabels = f.maker ? uniqueSorted(rows.map(r => r[f.maker])) : [];
    const parkLabels  = f.park  ? uniqueSorted(rows.map(r => r[f.park]))  : [];

    const makerCtl = (f.maker && makerLabels.length)
      ? drawChecklist(makerList, makerLabels, selectedMakers, makerSearch, render)
      : null;

    const parkCtl = (f.park && parkLabels.length)
      ? drawChecklist(parkList, parkLabels, selectedParks, parkSearch, render)
      : null;

    document.getElementById("makerClear").addEventListener("click", ()=>{
      if(makerCtl) makerCtl.clear(); render();
    });
    document.getElementById("parkClear").addEventListener("click", ()=>{
      if(parkCtl) parkCtl.clear(); render();
    });

    // tri anti-conflit (au sens près)
    let prevPrimary = sortSel.value;

    function updateSecondaryOptions(){
      const fam1 = sortFamily(sortSel.value);
      for(const opt of Array.from(sort2Sel.options)){
        opt.disabled = (sortFamily(opt.value) === fam1);
      }
      if(sortFamily(sort2Sel.value) === fam1){
        const firstValid = Array.from(sort2Sel.options).find(o => !o.disabled);
        if(firstValid) sort2Sel.value = firstValid.value;
      }
    }

    sortSel.addEventListener("change", ()=>{
      const newPrimary = sortSel.value;
      if(sortFamily(newPrimary) === sortFamily(sort2Sel.value)){
        sort2Sel.value = prevPrimary;
      }
      prevPrimary = newPrimary;
      updateSecondaryOptions();
      render();
    });
    sort2Sel.addEventListener("change", ()=>{ updateSecondaryOptions(); render(); });

    qEl.addEventListener("input", render);
    yearMinEl.addEventListener("input", render);
    yearMaxEl.addEventListener("input", render);

    document.getElementById("clear").addEventListener("click", ()=>{
      qEl.value = "";
      if(makerCtl) makerCtl.clear();
      if(parkCtl) parkCtl.clear();

      yearMinEl.value = String(absMin);
      yearMaxEl.value = String(absMax);

      sortSel.value = "park_asc";
      sort2Sel.value = "year_asc";
      prevPrimary = sortSel.value;

      expandedKey = null; // replier
      updateSecondaryOptions();
      render();
    });

    updateSecondaryOptions();

    // Gestion “fiche ouverte”
    // On garde 1 fiche ouverte à la fois (plus propre). Si tu veux multi-ouvert, je te le fais.
    let expandedKey = null;

    function keyForRow(r, idx){
      // clé stable : nom + parc + idx (fallback)
      const n = String(r[f.name] ?? "").trim();
      const p = f.park ? String(r[f.park] ?? "").trim() : "";
      return `${n}__${p}__${idx}`;
    }

    function render(){
      const q = norm(qEl.value);
      const {min, max} = updateSliderUI(absMin, absMax);

      let filtered = rows.filter(r=>{
        if(!hasCoasterName(r, f.name)) return false;
        if(!matchesQuery(r, q)) return false;

        if(f.maker && selectedMakers.size){
          const m = String(r[f.maker] ?? "").trim();
          if(!selectedMakers.has(m)) return false;
        }
        if(f.park && selectedParks.size){
          const p = String(r[f.park] ?? "").trim();
          if(!selectedParks.has(p)) return false;
        }

        if(f.year){
          const y = toYear(r[f.year]);
          if(y === null){
            if(min !== absMin || max !== absMax) return false;
          } else {
            if(y < min || y > max) return false;
          }
        }

        return true;
      });

      filtered = sortRows(filtered, sortSel.value, sort2Sel.value, f);

      if(filtered.length === 0){
        grid.innerHTML = `<div class="empty">Aucun résultat.</div>`;
        return;
      }

      grid.innerHTML = filtered.map((r, i) => {
        const k = keyForRow(r, i);
        const expanded = (expandedKey === k);
        return cardHTML(r, f, i, expanded);
      }).join("");

      // click handlers (accordéon)
      grid.querySelectorAll(".cardBtn").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const card = btn.closest(".card");
          const idx = Number(card.getAttribute("data-idx"));
          const r = filtered[idx];
          const k = keyForRow(r, idx);

          expandedKey = (expandedKey === k) ? null : k;
          render();
        });
      });
    }

    render();

  } catch(e){
    console.error(e);
    showError(
      "Erreur:\n" + (e?.message ?? String(e)) +
      "\n\nÀ vérifier:\n- data/coasters_clean.json existe\n- JSON valide (tableau)\n- GitHub Pages (pas file://)"
    );
  }
})();
</script>
</body>
</html>

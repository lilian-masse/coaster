<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coasters — Fiches</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 6px; }
    .muted { opacity: .75; margin-bottom: 16px; line-height: 1.35; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    .error {
      border: 1px solid #f0c2c2;
      background: #fff5f5;
      color: #7a1f1f;
      padding: 12px 14px;
      border-radius: 12px;
      margin: 14px 0;
      white-space: pre-wrap;
      display: none;
    }

    .bar { display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); gap: 12px; margin: 16px 0 18px; align-items: start; }
    .field { grid-column: span 3; }
    .field.wide { grid-column: span 6; }
    .field.actions { grid-column: span 2; display: flex; gap: 10px; align-items: end; }

    label { display:block; font-size: 14px; margin-bottom: 6px; }
    input, select, button { padding: 10px 12px; font-size: 14px; width: 100%; box-sizing: border-box; }
    button { cursor: pointer; }

    .multibox {
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      box-shadow: 0 1px 6px rgba(0,0,0,.03);
    }
    .multibox .search { margin-bottom: 8px; }
    .multibox .list {
      max-height: 220px;
      overflow: auto;
      border-top: 1px solid #eee;
      padding-top: 8px;
    }
    .multibox .row {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 6px 2px;
      font-size: 13px;
    }
    .multibox .row input { width: auto; }
    .multibox .tools {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .multibox .tools button{
      width: auto;
      padding: 8px 10px;
      font-size: 13px;
    }

    /* --- Double slider (2 poignées) --- */
    .rangebox{
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      box-shadow: 0 1px 6px rgba(0,0,0,.03);
    }
    .range-top{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
      font-size: 13px;
      opacity: .9;
    }
    .range-values{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }
    .range-values .pill{ font-size: 12px; }
    .range-wrap{
      position: relative;
      height: 34px;
    }
    .range-wrap input[type="range"]{
      position: absolute;
      left: 0;
      top: 8px;
      width: 100%;
      margin: 0;
      padding: 0;
      background: none;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
      height: 18px;
    }
    .range-wrap input[type="range"]::-webkit-slider-runnable-track{
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .range-wrap input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      pointer-events: auto;
      height: 18px;
      width: 18px;
      border-radius: 50%;
      border: 1px solid #bbb;
      background: #fff;
      box-shadow: 0 1px 6px rgba(0,0,0,.12);
      cursor: pointer;
    }
    .range-wrap input[type="range"]::-moz-range-track{
      height: 6px;
      border-radius: 999px;
      background: transparent;
    }
    .range-wrap input[type="range"]::-moz-range-thumb{
      pointer-events: auto;
      height: 18px;
      width: 18px;
      border-radius: 50%;
      border: 1px solid #bbb;
      background: #fff;
      box-shadow: 0 1px 6px rgba(0,0,0,.12);
      cursor: pointer;
    }
    .track{
      position:absolute;
      left: 0;
      right: 0;
      top: 14px;
      height: 6px;
      border-radius: 999px;
      background: #eee;
    }
    .range{
      position:absolute;
      top: 14px;
      height: 6px;
      border-radius: 999px;
      background: #cfcfcf;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 14px;
    }
    .card {
      border: 1px solid #e6e6e6;
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 1px 6px rgba(0,0,0,.04);
      background: #fff;
    }
    .title { font-weight: 750; font-size: 16px; margin: 0 0 8px; }
    .sub { opacity: .8; margin: 0 0 10px; font-size: 13px; }
    .kv { display: grid; grid-template-columns: 110px 1fr; gap: 6px 10px; font-size: 13px; }
    .k { opacity: .65; }
    .v { word-break: break-word; }

    .footer {
      margin-top: 18px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }
    .empty { padding: 18px; border: 1px dashed #ddd; border-radius: 16px; opacity: .8; }

    @media (max-width: 980px){
      .bar { grid-template-columns: repeat(6, minmax(0, 1fr)); }
      .field { grid-column: span 3; }
      .field.wide { grid-column: span 6; }
      .field.actions { grid-column: span 6; }
    }
    @media (max-width: 560px){
      .bar { grid-template-columns: repeat(1, minmax(0, 1fr)); }
      .field, .field.wide, .field.actions { grid-column: span 1; }
    }
  </style>
</head>
<body>
  <h1>Coasters</h1>
  <div class="muted">
    Fiches avec recherche + filtres (Fabricants / Parcs) + ouverture (slider) + tri principal/secondaire.
    <span id="count" class="pill">…</span>
  </div>

  <div id="err" class="error"></div>

  <div class="bar">
    <div class="field wide">
      <label for="q">Recherche (tous champs)</label>
      <input id="q" type="text" placeholder="ex: Intamin, Disneyland, wood, vitesse..." />
    </div>

    <div class="field">
      <label>Fabricants</label>
      <div class="multibox" id="makerBox">
        <input class="search" id="makerSearch" type="text" placeholder="Rechercher un fabricant…" />
        <div class="list" id="makerList"></div>
        <div class="tools">
          <button type="button" id="makerNone">Aucun</button>
        </div>
      </div>
    </div>

    <div class="field">
      <label>Parcs</label>
      <div class="multibox" id="parkBox">
        <input class="search" id="parkSearch" type="text" placeholder="Rechercher un parc…" />
        <div class="list" id="parkList"></div>
        <div class="tools">
          <button type="button" id="parkNone">Aucun</button>
        </div>
      </div>
    </div>

    <div class="field">
      <label>Ouverture (année)</label>
      <div class="rangebox">
        <div class="range-top">
          <div class="range-values">
            <span class="pill" id="yearMinPill">—</span>
            <span>→</span>
            <span class="pill" id="yearMaxPill">—</span>
          </div>
          <span class="pill" id="yearSpanPill">—</span>
        </div>
        <div class="range-wrap">
          <div class="track"></div>
          <div class="range" id="yearRangeFill"></div>
          <input id="yearMin" type="range" min="1900" max="2025" value="1900" step="1" aria-label="Année minimum">
          <input id="yearMax" type="range" min="1900" max="2025" value="2025" step="1" aria-label="Année maximum">
        </div>
      </div>
    </div>

    <div class="field">
      <label for="sort">Tri</label>
      <select id="sort">
        <!-- plus de Z->A, plus de tri par nom de coaster -->
        <option value="park_asc" selected>Parc A→Z</option>
        <option value="year_asc">Ouverture ↑</option>
        <option value="year_desc">Ouverture ↓</option>
      </select>
    </div>

    <div class="field">
      <label for="sort2">Tri secondaire</label>
      <select id="sort2">
        <!-- plus de Z->A, plus de tri par nom de coaster -->
        <option value="year_asc" selected>Ouverture ↑</option>
        <option value="year_desc">Ouverture ↓</option>
        <option value="park_asc">Parc A→Z</option>
      </select>
    </div>

    <div class="field actions">
      <button id="clear" type="button">Réinitialiser</button>
    </div>
  </div>

  <div id="grid" class="grid"></div>

  <div class="footer">
    <div class="info">
      <span class="pill" id="activeFilters">Filtres: aucun</span>
    </div>
    <div class="info">
      <span id="status" class="pill">Affichage: tous</span>
    </div>
  </div>

  <script>
    const dataUrl = "./data/coasters_clean.json";

    const errBox = document.getElementById("err");
    function showError(msg){ errBox.style.display = "block"; errBox.textContent = msg; }
    function clearError(){ errBox.style.display = "none"; errBox.textContent = ""; }

    const norm = (v) => String(v ?? "").trim().toLowerCase();

    function escapeHtml(str){
      return String(str ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#039;");
    }

    function titleize(s){
      return (s||"").replace(/_/g," ").replace(/\b\w/g, c => c.toUpperCase());
    }

    function pickField(obj, candidates){
      const keys = Object.keys(obj || {});
      const lower = new Map(keys.map(k => [k.toLowerCase(), k]));
      for (const c of candidates){
        const hit = lower.get(String(c).toLowerCase());
        if (hit) return hit;
      }
      return null;
    }

    function toNumber(v){
      const s = String(v ?? "").trim();
      if(!s) return null;
      const cleaned = s.replace(/[^0-9.\-]/g, "");
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : null;
    }

    function toYear(v){
      const n = toNumber(v);
      if(n === null) return null;

      if(n >= 1800 && n <= 2200) return Math.trunc(n);

      if(n > 1e11){
        const d = new Date(n);
        const y = d.getUTCFullYear();
        return Number.isFinite(y) ? y : null;
      }

      if(n > 1e9){
        const d = new Date(n * 1000);
        const y = d.getUTCFullYear();
        return Number.isFinite(y) ? y : null;
      }

      return null;
    }

    function matchesQuery(row, q){
      if(!q) return true;
      const text = Object.values(row).map(v => String(v ?? "")).join(" ").toLowerCase();
      return text.includes(q);
    }

    function uniqueSortedLabels(values){
      const cleaned = values.map(v => String(v ?? "").trim()).filter(v => v !== "");
      const uniq = Array.from(new Set(cleaned));
      uniq.sort((a,b)=>a.localeCompare(b, "fr"));
      return uniq;
    }

    function buildChecklist({containerEl, searchEl, noneBtn, labels, onChange}){
      const selected = new Set();

      function draw(filterText){
        const ft = norm(filterText);
        const shown = labels.filter(l => norm(l).includes(ft));

        containerEl.innerHTML = shown.map(label => {
          const value = norm(label);
          const checked = selected.has(value) ? "checked" : "";
          return `
            <div class="row">
              <input type="checkbox" value="${escapeHtml(value)}" ${checked} />
              <span>${escapeHtml(label)}</span>
            </div>
          `;
        }).join("");

        containerEl.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.addEventListener("change", () => {
            if(cb.checked) selected.add(cb.value);
            else selected.delete(cb.value);
            onChange();
          });
        });
      }

      function clearAll(){
        selected.clear();
        draw(searchEl.value);
        onChange();
      }

      searchEl.addEventListener("input", () => draw(searchEl.value));
      noneBtn.addEventListener("click", clearAll);

      draw("");

      return {
        getSelectedSet: () => new Set(selected),
        clear: () => { selected.clear(); draw(""); },
      };
    }

    function hasCoasterName(r, f){
      if(!f.nameField) return false;
      const n = String(r[f.nameField] ?? "").trim().toLowerCase();
      if(!n) return false;
      if(n === "n/a" || n === "na" || n === "unknown" || n === "-" || n === "—") return false;
      return true;
    }

    function renderCard(row, f){
      const title = String(row[f.nameField] ?? "").trim();

      const subParts = [];
      if (f.parkField && row[f.parkField]) subParts.push(row[f.parkField]);
      const sub = subParts.join(" • ");

      const show = [];
      const pushIf = (label, field) => {
        if (field && row[field] !== null && row[field] !== undefined && String(row[field]).trim() !== "") {
          show.push([label, row[field]]);
        }
      };

      pushIf("Fabricant", f.makerField);
      pushIf("Parc", f.parkField);

      if (f.yearField){
        const y = toYear(row[f.yearField]);
        if (y !== null) show.push(["Ouverture", y]);
        else pushIf("Ouverture", f.yearField);
      }

      pushIf("Vitesse", f.speedField);
      pushIf("Hauteur", f.heightField);
      pushIf("Longueur", f.lengthField);
      pushIf("Inversions", f.inversionsField);

      if(show.length === 0){
        Object.entries(row).slice(0, 8).forEach(([k,v]) => {
          if (String(v??"").trim() !== "") show.push([titleize(k), v]);
        });
      }

      return `
        <article class="card">
          <h2 class="title">${escapeHtml(title)}</h2>
          ${sub ? `<p class="sub">${escapeHtml(sub)}</p>` : ""}
          <div class="kv">
            ${show.map(([k,v]) => `
              <div class="k">${escapeHtml(k)}</div>
              <div class="v">${escapeHtml(v)}</div>
            `).join("")}
          </div>
        </article>
      `;
    }

    // Normalise "au sens près" : on ignore l'ordre (asc/desc) et on garde uniquement la famille du tri
    // ex: year_asc et year_desc => même sens (year)
    //     park_asc => park
    function sortFamily(mode){
      return String(mode || "").split("_")[0]; // "year" ou "park"
    }

    function sortRows(list, mode1, mode2, f){
      const getYear = (r) => f.yearField ? (toYear(r[f.yearField]) ?? null) : null;
      const getPark = (r) => f.parkField ? String(r[f.parkField] ?? "") : "";

      function cmp(mode, a, b){
        if(mode === "year_desc"){
          return (getYear(b) ?? -Infinity) - (getYear(a) ?? -Infinity);
        }
        if(mode === "year_asc"){
          return (getYear(a) ?? Infinity) - (getYear(b) ?? Infinity);
        }
        if(mode === "park_asc"){
          return getPark(a).localeCompare(getPark(b), "fr");
        }
        return 0;
      }

      return list.slice().sort((a,b) => {
        let c = cmp(mode1, a, b);
        if(c !== 0) return c;

        c = cmp(mode2, a, b);
        if(c !== 0) return c;

        // fallback stable : parc puis année
        c = cmp("park_asc", a, b);
        if(c !== 0) return c;
        return cmp("year_asc", a, b);
      });
    }

    function clampMinMax(minEl, maxEl){
      let a = parseInt(minEl.value, 10);
      let b = parseInt(maxEl.value, 10);
      if(a > b){
        const t = a; a = b; b = t;
        minEl.value = String(a);
        maxEl.value = String(b);
      }
      return {min: a, max: b};
    }

    function updateYearUI(minEl, maxEl, yMinAbs, yMaxAbs){
      const {min, max} = clampMinMax(minEl, maxEl);

      document.getElementById("yearMinPill").textContent = String(min);
      document.getElementById("yearMaxPill").textContent = String(max);
      document.getElementById("yearSpanPill").textContent = (min === yMinAbs && max === yMaxAbs)
        ? "toutes les années"
        : `${max - min + 1} an(s)`;

      const fill = document.getElementById("yearRangeFill");
      const total = (yMaxAbs - yMinAbs) || 1;
      const leftPct = ((min - yMinAbs) / total) * 100;
      const rightPct = ((max - yMinAbs) / total) * 100;
      fill.style.left = leftPct + "%";
      fill.style.width = Math.max(0, rightPct - leftPct) + "%";
    }

    (async function init(){
      const grid = document.getElementById("grid");
      const countEl = document.getElementById("count");
      const activeFiltersEl = document.getElementById("activeFilters");
      const statusEl = document.getElementById("status");

      const qEl = document.getElementById("q");
      const sortSel = document.getElementById("sort");
      const sort2Sel = document.getElementById("sort2");

      const makerSearch = document.getElementById("makerSearch");
      const makerList = document.getElementById("makerList");
      const makerNone = document.getElementById("makerNone");

      const parkSearch = document.getElementById("parkSearch");
      const parkList = document.getElementById("parkList");
      const parkNone = document.getElementById("parkNone");

      const makerBox = document.getElementById("makerBox");
      const parkBox  = document.getElementById("parkBox");

      const yearMinEl = document.getElementById("yearMin");
      const yearMaxEl = document.getElementById("yearMax");

      clearError();

      try{
        const res = await fetch(dataUrl, { cache: "no-store" });
        if(!res.ok) throw new Error(`Fetch échoué (${res.status}) sur ${dataUrl}`);

        let rows;
        try { rows = await res.json(); }
        catch { throw new Error("JSON invalide (impossible de parser). Vérifie data/coasters_clean.json."); }

        if(!Array.isArray(rows)) throw new Error("Le JSON doit être un tableau d’objets: [ {..}, {..} ]");
        if(rows.length === 0){ grid.innerHTML = `<div class="empty">Le fichier JSON est vide.</div>`; return; }

        const sample = rows[0] || {};

        const f = {
          nameField: pickField(sample, ["Nom", "Coaster", "Name", "name", "coaster", "ride", "attraction"]),
          parkField: pickField(sample, ["Parc", "Park", "park", "parc", "location"]),
          makerField: pickField(sample, ["Fabricant", "Fabricant_2", "Constructeur", "Manufacturer", "manufacturer", "maker", "builder"]),
          yearField: pickField(sample, ["Ouverture", "Année", "Annee", "Year", "year", "opened", "opening_year"]),
          speedField: pickField(sample, ["Vitesse", "Speed", "speed", "top_speed"]),
          heightField: pickField(sample, ["Hauteur", "Height", "height"]),
          lengthField: pickField(sample, ["Longueur", "Length", "length"]),
          inversionsField: pickField(sample, ["Inversions", "inversions", "nb_inversions"]),
        };

        if(!f.nameField){
          throw new Error("Champ 'Nom de coaster' introuvable dans le JSON. Vérifie la clé (ex: 'Nom' ou 'Coaster').");
        }

        // Intervalle d'années global
        let yMinAbs = 1900;
        let yMaxAbs = new Date().getUTCFullYear();
        if(f.yearField){
          const years = rows.map(r => toYear(r[f.yearField])).filter(y => Number.isFinite(y));
          if(years.length){
            yMinAbs = Math.min(...years);
            yMaxAbs = Math.max(...years);
          }
        }

        // Init sliders
        yearMinEl.min = String(yMinAbs);
        yearMinEl.max = String(yMaxAbs);
        yearMaxEl.min = String(yMinAbs);
        yearMaxEl.max = String(yMaxAbs);
        yearMinEl.value = String(yMinAbs);
        yearMaxEl.value = String(yMaxAbs);
        updateYearUI(yearMinEl, yearMaxEl, yMinAbs, yMaxAbs);

        let makerCtl = null;
        let parkCtl = null;

        if(f.makerField){
          const makerLabels = uniqueSortedLabels(rows.map(r => r[f.makerField]));
          makerCtl = buildChecklist({
            containerEl: makerList,
            searchEl: makerSearch,
            noneBtn: makerNone,
            labels: makerLabels,
            onChange: () => render()
          });
        } else {
          makerBox.innerHTML = `<div class="empty">Champ "Fabricant" non trouvé.</div>`;
        }

        if(f.parkField){
          const parkLabels = uniqueSortedLabels(rows.map r => r[f.parkField]));
          parkCtl = buildChecklist({
            containerEl: parkList,
            searchEl: parkSearch,
            noneBtn: parkNone,
            labels: parkLabels,
            onChange: () => render()
          });
        } else {
          parkBox.innerHTML = `<div class="empty">Champ "Parc" non trouvé.</div>`;
        }

        // --- règle anti-identique (au sens près) + désactivation des options secondaires ---
        // Quand le principal devient identique au secondaire AU SENS PRÈS (famille),
        // on met le secondaire à la valeur de l'ancien principal (exacte).
        let prevPrimary = sortSel.value;

        function updateSecondaryOptions(){
          const fam1 = sortFamily(sortSel.value);
          Array.from(sort2Sel.options).forEach(opt => {
            opt.disabled = (sortFamily(opt.value) === fam1);
          });

          // si l'option actuellement sélectionnée devient invalide, basculer sur la première option valide
          if(sortFamily(sort2Sel.value) === fam1){
            const firstValid = Array.from(sort2Sel.options).find(o => !o.disabled);
            if(firstValid) sort2Sel.value = firstValid.value;
          }
        }

        function enforceSwapIfSameFamily(newPrimary){
          const famP = sortFamily(newPrimary);
          const famS = sortFamily(sort2Sel.value);
          if(famP === famS){
            // mettre le secondaire à l'ancien principal (exact)
            sort2Sel.value = prevPrimary;
          }
          prevPrimary = newPrimary;
        }

        // init: empêcher secondaire d'être "park" si principal "park"
        updateSecondaryOptions();
        // si malgré tout principal et secondaire sont en conflit, on corrige
        enforceSwapIfSameFamily(sortSel.value);
        updateSecondaryOptions();

        sortSel.addEventListener("change", () => {
          const newPrimary = sortSel.value;
          enforceSwapIfSameFamily(newPrimary);
          updateSecondaryOptions();
          render();
        });

        sort2Sel.addEventListener("change", () => {
          // le menu empêche normalement, mais on sécurise
          updateSecondaryOptions();
          render();
        });

        function activeFiltersText(state){
          const parts = [];
          if(state.q) parts.push(`Recherche: “${state.q}”`);
          if(state.makers.size) parts.push(`Fabricants: ${state.makers.size}`);
          if(state.parks.size) parts.push(`Parcs: ${state.parks.size}`);
          if(state.ymin !== yMinAbs || state.ymax !== yMaxAbs){
            parts.push(`Ouverture: ${state.ymin}–${state.ymax}`);
          }
          parts.push(`Tri: ${sortSel.options[sortSel.selectedIndex].textContent}`);
          parts.push(`Puis: ${sort2Sel.options[sort2Sel.selectedIndex].textContent}`);
          return parts.join(" • ");
        }

        function render(){
          try{
            const makersSet = makerCtl ? makerCtl.getSelectedSet() : new Set();
            const parksSet  = parkCtl  ? parkCtl.getSelectedSet()  : new Set();

            const {min: ymin, max: ymax} = clampMinMax(yearMinEl, yearMaxEl);
            updateYearUI(yearMinEl, yearMaxEl, yMinAbs, yMaxAbs);

            const state = {
              q: norm(qEl.value),
              makers: makersSet,
              parks: parksSet,
              ymin, ymax,
              sort: sortSel.value,
              sort2: sort2Sel.value
            };

            let filtered = rows.filter(r => {
              if(!hasCoasterName(r, f)) return false;

              if(!matchesQuery(r, state.q)) return false;

              if(f.makerField && state.makers.size){
                if(!state.makers.has(norm(r[f.makerField]))) return false;
              }
              if(f.parkField && state.parks.size){
                if(!state.parks.has(norm(r[f.parkField]))) return false;
              }

              if(f.yearField){
                const y = toYear(r[f.yearField]);
                if(y === null){
                  if(state.ymin !== yMinAbs || state.ymax !== yMaxAbs) return false;
                } else {
                  if(y < state.ymin || y > state.ymax) return false;
                }
              }

              return true;
            });

            filtered = sortRows(filtered, state.sort, state.sort2, f);

            const total = filtered.length;
            countEl.textContent = `${total} résultat(s)`;
            activeFiltersEl.textContent = "Filtres: " + activeFiltersText(state);
            statusEl.textContent = "Affichage: tous";

            if(total === 0){
              grid.innerHTML = `<div class="empty">Aucun résultat. Essaie d’enlever un filtre.</div>`;
              return;
            }

            grid.innerHTML = filtered.map(r => renderCard(r, f)).join("");
          } catch(e){
            console.error(e);
            showError("Erreur pendant le rendu:\n" + (e?.message ?? String(e)));
          }
        }

        qEl.addEventListener("input", render);
        yearMinEl.addEventListener("input", render);
        yearMaxEl.addEventListener("input", render);

        // Defaults demandés : principal=park A→Z, secondaire=ouverture ↑
        sortSel.value = "park_asc";
        sort2Sel.value = "year_asc";
        prevPrimary = sortSel.value;
        updateSecondaryOptions();

        document.getElementById("clear").addEventListener("click", () => {
          qEl.value = "";

          sortSel.value = "park_asc";
          sort2Sel.value = "year_asc";
          prevPrimary = sortSel.value;
          updateSecondaryOptions();

          if(makerCtl) makerCtl.clear();
          if(parkCtl) parkCtl.clear();
          makerSearch.value = "";
          parkSearch.value = "";

          yearMinEl.value = String(yMinAbs);
          yearMaxEl.value = String(yMaxAbs);
          updateYearUI(yearMinEl, yearMaxEl, yMinAbs, yMaxAbs);

          render();
        });

        render();

      } catch(e){
        console.error(e);
        showError(
          "La page n’a pas pu charger les données.\n\n" +
          (e?.message ?? String(e)) +
          "\n\nÀ vérifier:\n- le fichier existe bien: /data/coasters_clean.json\n- le JSON est valide (format tableau)\n- tu consultes via GitHub Pages (pas file://)"
        );
      }
    })();
  </script>
</body>
</html>

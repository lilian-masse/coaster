<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Coasters — Fiches</title>

<style>
  :root{
    --b:#e6e6e6;--bg:#fff;--shadow:0 1px 6px rgba(0,0,0,.04);
    --cardsMinH: 520px; /* ✅ hauteur stable de la zone fiches */
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:24px}
  h1{margin:0 0 10px}
  .bar{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:14px;margin-bottom:22px;align-items:start}
  label{font-size:13px;margin-bottom:4px;display:block}
  input,select,button{padding:9px 10px;font-size:14px;width:100%;box-sizing:border-box}
  button{cursor:pointer}

  .box{border:1px solid var(--b);border-radius:12px;padding:10px;background:var(--bg);box-shadow:0 1px 6px rgba(0,0,0,.03)}
  .boxTitle{font-weight:700;font-size:13px;margin:0 0 8px}

  /* scroll zone + bannière sticky "sélectionnés" */
  .listWrap{max-height:190px;overflow:auto;border-top:1px solid #eee;margin-top:8px;padding-top:8px;position:relative}
  .selBanner{
    position:sticky;top:0;z-index:5;
    display:none;
    padding:6px 8px;margin:-8px 0 8px;
    background:rgba(255,255,255,.92);
    border:1px solid #eee;border-radius:10px;
    font-size:12px;font-weight:700;
    backdrop-filter: blur(3px);
  }
  .row{display:flex;gap:8px;align-items:center;padding:6px 2px;font-size:13px}
  .row input{width:auto}
  .row small{opacity:.65;margin-left:auto}
  .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .tools button{width:auto;padding:8px 10px;font-size:13px}

  .rangeWrap{border:1px solid var(--b);border-radius:12px;padding:10px;background:var(--bg);box-shadow:0 1px 6px rgba(0,0,0,.03)}
  .rangeHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
  .rangeHead .name{font-weight:700;font-size:13px}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #ddd;border-radius:999px;font-size:12px;opacity:.9}

  .dual{position:relative;height:36px}
  .dual input[type="range"]{
    position:absolute;left:0;top:9px;width:100%;
    margin:0;padding:0;background:none;
    pointer-events:none;-webkit-appearance:none;appearance:none;height:18px
  }
  .dual input[type="range"]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:transparent}
  .dual input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;appearance:none;pointer-events:auto;
    height:16px;width:16px;border-radius:50%;
    border:1px solid #999;background:#fff;box-shadow:0 1px 6px rgba(0,0,0,.12);cursor:pointer
  }
  .track{position:absolute;left:0;right:0;top:15px;height:6px;background:#eee;border-radius:999px}
  .fill{position:absolute;top:15px;height:6px;background:#ccc;border-radius:999px}
  .rangeMeta{display:flex;justify-content:space-between;font-size:12px;opacity:.75;margin-top:6px}

  /* ✅ NOUVEAU : frame stable pour les résultats */
  .cardsFrame{
    border:1px solid var(--b);
    border-radius:16px;
    background:#fff;
    box-shadow:var(--shadow);
    padding:12px;
    min-height: var(--cardsMinH);
    box-sizing:border-box;
  }
  /* scroll interne si la grille devient longue */
  .cardsScroll{
    max-height: calc(100vh - 120px); /* évite d'être trop grand */
    overflow:auto;
    padding:2px;
  }

  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px}
  .card{border:1px solid var(--b);border-radius:14px;background:#fff;box-shadow:var(--shadow);padding:14px;cursor:pointer}
  .card:focus{outline:2px solid #cfcfcf;outline-offset:2px}
  .title{font-weight:750;margin:0 0 6px;font-size:16px}
  .sub{opacity:.75;margin:0 0 10px;font-size:13px}
  .kv{display:grid;grid-template-columns:130px 1fr;gap:6px 10px;font-size:13px}
  .k{opacity:.6}
  .v{word-break:break-word}

  .empty{padding:18px;border:1px dashed #ccc;border-radius:12px;opacity:.85;background:#fff}
  .error{display:none;white-space:pre-wrap;border:1px solid #f0c2c2;background:#fff5f5;color:#7a1f1f;padding:10px 12px;border-radius:12px;margin:12px 0}

  .modalOverlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:18px;z-index:1000}
  .modalOverlay.open{display:flex}
  .modalWrap{position:relative;width:min(820px, 100%);display:flex;align-items:center;justify-content:center}
  .modal{width:100%;max-height:min(82vh, 820px);overflow:auto;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);border:1px solid #eee}
  .modalHeader{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:14px 16px}
  .modalTitle{font-weight:800;margin:0;font-size:18px;line-height:1.25}
  .modalSub{margin:4px 0 0;opacity:.7;font-size:13px}
  .modalBody{padding:14px 16px 18px}
  .modalGrid{display:grid;grid-template-columns:180px 1fr;gap:8px 12px;font-size:14px}
  .modalK{opacity:.65}
  .modalV{word-break:break-word}
  @media (max-width:560px){ .modalGrid{grid-template-columns:1fr;gap:6px} }

  .navArrow{
    position:absolute;top:50%;transform:translateY(-50%);
    width:46px;height:46px;border-radius:999px;
    border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.28);color:#fff;
    display:flex;align-items:center;justify-content:center;
    cursor:pointer;user-select:none;font-size:26px;line-height:1;padding:0;
  }
  .navArrow:hover{background:rgba(0,0,0,.38)}
  .navArrow:focus{outline:2px solid rgba(255,255,255,.65);outline-offset:2px}
  .navLeft{left:-10px}
  .navRight{right:-10px}
  .navArrow[disabled]{display:none}
  @media (max-width:520px){
    .navLeft{left:4px}.navRight{right:4px}.navArrow{width:42px;height:42px;font-size:24px}
  }

  .sectionTitle{font-weight:800;margin:18px 0 8px;font-size:14px;opacity:.85}
</style>
</head>

<body>
<h1>Coasters</h1>

<div class="bar">
  <div>
    <label>Recherche</label>
    <input id="q" placeholder="Rechercher…">
  </div>

  <div>
    <label>Tri principal</label>
    <select id="sort">
      <option value="park_asc" selected>Parc A→Z</option>
      <option value="year_asc">Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
    </select>
  </div>

  <div>
    <label>Tri secondaire</label>
    <select id="sort2">
      <option value="year_asc" selected>Ouverture ↑</option>
      <option value="year_desc">Ouverture ↓</option>
      <option value="park_asc">Parc A→Z</option>
    </select>
  </div>

  <div class="box">
    <div class="boxTitle">Eau ?</div>
    <label class="row" style="padding:0;margin:0;gap:10px">
      <input id="waterOnly" type="checkbox">
      <span>Afficher seulement les coasters “Eau”</span>
      <small id="waterCount">—</small>
    </label>
  </div>

  <div style="align-self:end">
    <button id="clear" type="button">Réinitialiser</button>
  </div>
</div>

<div class="sectionTitle">Filtres</div>
<div class="bar" id="facetBar"></div>

<div class="sectionTitle">Plages numériques</div>
<div class="bar" id="sliderBar"></div>

<div id="err" class="error"></div>

<!-- ✅ NOUVEAU : frame stable -->
<div class="cardsFrame">
  <div class="cardsScroll">
    <div id="grid" class="grid"></div>
  </div>
</div>

<div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modalWrap">
    <button id="navLeft" class="navArrow navLeft" type="button" aria-label="Précédent">‹</button>
    <div class="modal" role="document">
      <div class="modalHeader">
        <h2 id="modalTitle" class="modalTitle">—</h2>
        <p id="modalSub" class="modalSub"></p>
        <p class="pill" style="margin:10px 0 0;display:inline-block;opacity:.85">Clique en dehors, Échap, ou flèches ← →</p>
      </div>
      <div class="modalBody">
        <div id="modalGrid" class="modalGrid"></div>
      </div>
    </div>
    <button id="navRight" class="navArrow navRight" type="button" aria-label="Suivant">›</button>
  </div>
</div>

<script>
const dataUrl = "./data/coasters_clean.json";
const $ = (id)=>document.getElementById(id);

function showError(msg){ $("err").style.display="block"; $("err").textContent = msg; }
function clearError(){ $("err").style.display="none"; $("err").textContent = ""; }

function norm(s){
  return String(s ?? "")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\s+/g," ")
    .trim();
}
function esc(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/\"/g,"&quot;").replace(/'/g,"&#039;");
}
function toNumber(v){
  const s = String(v ?? "").trim();
  if(!s) return null;
  const cleaned = s.replace(/[^0-9.\-]/g,"");
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : null;
}
function toInt(v){
  const n = toNumber(v);
  if(n === null) return null;
  return Math.round(n);
}
function toYear(v){
  const n = toNumber(v);
  if(n === null) return null;
  if(n >= 1800 && n <= 2200) return Math.trunc(n);
  const a = Math.abs(n);
  if(a > 1e11){ const y = new Date(n).getUTCFullYear(); return Number.isFinite(y) ? y : null; }
  if(a > 1e9){ const y = new Date(n*1000).getUTCFullYear(); return Number.isFinite(y) ? y : null; }
  return null;
}
function titleizeKey(k){
  const s = String(k ?? "").replace(/_/g," ").trim();
  if(!s) return "Champ";
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function sortFamily(mode){ return String(mode||"").split("_")[0]; }
function pickField(obj, candidates){
  const keys = Object.keys(obj || {});
  const map = new Map(keys.map(k => [norm(k), k]));
  for(const c of candidates){
    const hit = map.get(norm(c));
    if(hit) return hit;
  }
  for(const k of keys){
    const nk = norm(k);
    if(candidates.some(c => nk.includes(norm(c)))) return k;
  }
  return null;
}

/* ---------- Specs ---------- */
const FACET_SPECS = [
  { id:"maker", label:"Fabricant", candidates:["Fabricant","Manufacturer","Constructeur","Builder","Maker"] },
  { id:"park", label:"Parc", candidates:["Parc","Park"] },
  { id:"model", label:"Modèle", candidates:["Modele","Modèle","Model"] },
  { id:"propulsion", label:"Propulsion", candidates:["Propulsion","Launch","Type de propulsion"] },
  { id:"launchAngle", label:"Angle de propulsion", candidates:["Angle de propulsion","Launch angle","Angle propulsion"] },
  { id:"structure", label:"Structure", candidates:["Structure","Structure type"] },
  { id:"particularity", label:"Particularité", candidates:["Particularite","Particularité","Particularity","Spécificité","Specificite"] },
  { id:"rotation", label:"Rotation", candidates:["Rotation","Rotating"] },
  { id:"layout", label:"Disposition", candidates:["Disposition","Layout","Implantation"] },
  { id:"restraint", label:"Sécurité", candidates:["Securite","Sécurité","Restraint","Restraints"] },
];

const NUM_SPECS = [
  { id:"year", label:"Ouverture", candidates:["Ouverture","Année","Annee","Year","Opened","Opening year"], isYear:true, step:1, integer:true },
  { id:"height", label:"Hauteur", candidates:["Hauteur","Height"], step:1, integer:true },
  { id:"speed", label:"Vitesse", candidates:["Vitesse","Speed"], step:1, integer:true },
  { id:"inversions", label:"Inversions", candidates:["Inversions","Inversion"], step:1, integer:true },
  { id:"length", label:"Longueur", candidates:["Longueur","Length"], step:1, integer:true },
  { id:"duration", label:"Durée", candidates:["Duree","Durée","Duration"], step:1, integer:true },
  { id:"capacity", label:"Débit", candidates:["Debit","Débit","Capacity","Throughput"], step:1, integer:true },

  { id:"seatsPerRow", label:"Sièges/rang.", candidates:["Sièges","Sieges","Sieges/rang.","Sièges/rang.","Seats/row","Seats per row","Sieges par rang"], step:1, integer:true },
  { id:"rowsPerCar", label:"Rangées/voit.", candidates:["Rangées","Rangees","Rangees/voit.","Rangées/voit.","Rows/car","Rows per car","Rangees par voiture"], step:1, integer:true },

    { id:"carsPerTrain", label:"Voit./train", candidates:["Voit./train","Cars/train","Cars per train","Voitures/train"], step:1, integer:true },
  
];

const WATER_CANDIDATES = ["Eau","Water","Splash","Aquatique"];

/* ---------- UI builders ---------- */
function createFacetBox(spec){
  const box = document.createElement("div");
  box.className = "box";
  box.innerHTML = `
    <div class="boxTitle">${esc(spec.label)}</div>
    <input id="search_${spec.id}" placeholder="Filtrer…">
    <div id="list_${spec.id}" class="listWrap">
      <div id="banner_${spec.id}" class="selBanner"></div>
      <div id="items_${spec.id}"></div>
    </div>
    <div class="tools">
      <button id="clear_${spec.id}" type="button">Effacer</button>
    </div>
  `;
  return box;
}
function createDualSlider(spec){
  const wrap = document.createElement("div");
  wrap.className = "rangeWrap";
  wrap.innerHTML = `
    <div class="rangeHead">
      <span class="name">${esc(spec.label)}</span>
      <span class="pill" id="pill_${spec.id}">—</span>
    </div>
    <div class="dual">
      <div class="track"></div>
      <div class="fill" id="fill_${spec.id}"></div>
      <input id="${spec.id}_min" type="range" aria-label="${esc(spec.label)} min">
      <input id="${spec.id}_max" type="range" aria-label="${esc(spec.label)} max">
    </div>
    <div class="rangeMeta">
      <span id="lab_${spec.id}_min">—</span>
      <span id="lab_${spec.id}_max">—</span>
    </div>
  `;
  return wrap;
}

/* ---------- Sorting ---------- */
function sortRows(list, mode1, mode2, f){
  const getYear = (r)=> f.year ? (toYear(r[f.year]) ?? null) : null;
  const getPark = (r)=> f.park ? String(r[f.park] ?? "") : "";
  function cmp(mode, a, b){
    if(mode === "year_desc") return (getYear(b) ?? -Infinity) - (getYear(a) ?? -Infinity);
    if(mode === "year_asc")  return (getYear(a) ?? Infinity) - (getYear(b) ?? Infinity);
    if(mode === "park_asc")  return getPark(a).localeCompare(getPark(b), "fr");
    return 0;
  }
  return list.slice().sort((a,b)=>{
    let c = cmp(mode1,a,b); if(c!==0) return c;
    c = cmp(mode2,a,b); if(c!==0) return c;
    c = cmp("park_asc",a,b); if(c!==0) return c;
    return cmp("year_asc",a,b);
  });
}

(async function(){
  clearError();

  const facetBar = $("facetBar");
  const sliderBar = $("sliderBar");
  const grid = $("grid");
  const qEl = $("q");
  const sortSel = $("sort");
  const sort2Sel = $("sort2");
  const waterOnlyEl = $("waterOnly");
  const waterCountEl = $("waterCount");

  const navLeftBtn = $("navLeft");
  const navRightBtn = $("navRight");
  const modalOverlay = $("modalOverlay");
  const modalTitleEl = $("modalTitle");
  const modalSubEl = $("modalSub");
  const modalGridEl = $("modalGrid");

  let allRows = [];
  let fields = {};
  let numFields = {};
  let waterField = null;

  const selected = {};
  const facetUI = {};
  const sliderUI = {};
  const sliderAbs = {};
  const sliderDyn = {};
  const sliderVal = {};
  const facetMasterOptions = {};
  const facetStableRank = {};

  let waterOnly = false;
  let lastRendered = [];
  let currentIndex = -1;

  function normalizeFacetValue(facetId, raw){
    let v = String(raw ?? "").trim();
    if(facetId === "launchAngle" && !v) return "Incliné";
    if(facetId === "structure" && !v) return "Acier";
    return v;
  }

  function parseWater(row){
    if(waterField){
      const s = norm(row[waterField]);
      if(!s) return false;
      return ["1","true","oui","yes","y","water","eau","splash"].some(t => s === t || s.includes(t));
    }
    const blob = Object.values(row).map(v=>String(v??"")).join(" ").toLowerCase();
    return blob.includes("eau") || blob.includes("water") || blob.includes("splash");
  }

  function computeDerivedSeats(row){
    const aKey = numFields.seatsPerRow;
    const bKey = numFields.rowsPerCar;
    const cKey = numFields.seatsPerCar;
    const dKey = numFields.carsPerTrain;
    
  }

  function clampSwap(minEl, maxEl){
    let a = Number(minEl.value);
    let b = Number(maxEl.value);
    if(a > b){
      const t=a; a=b; b=t;
      minEl.value = String(a);
      maxEl.value = String(b);
    }
    return {min:a, max:b};
  }

  function updateDualUI(id){
    const ui = sliderUI[id];
    const abs = sliderAbs[id];
    if(!ui || !abs || ui.minEl.disabled || ui.maxEl.disabled) return;

    // Pour les sliders "sièges" : on affiche toujours les bornes ABS du JSON
    // (pas de bornes dynamiques qui rétrécissent et bloquent l'augmentation).
    const SEAT_IDS = new Set(["seatsPerRow","rowsPerCar","carsPerTrain"]);
    const dyn = SEAT_IDS.has(id) ? abs : (sliderDyn[id] || abs);

    ui.minEl.min = String(dyn.min);
    ui.maxEl.min = String(dyn.min);
    ui.minEl.max = String(dyn.max);
    ui.maxEl.max = String(dyn.max);

    let minV = Math.round(Number(ui.minEl.value));
    let maxV = Math.round(Number(ui.maxEl.value));
    minV = Math.max(dyn.min, Math.min(dyn.max, minV));
    maxV = Math.max(dyn.min, Math.min(dyn.max, maxV));
    if(minV > maxV){ const t=minV; minV=maxV; maxV=t; }
    ui.minEl.value = String(minV);
    ui.maxEl.value = String(maxV);

    sliderVal[id] = {min:minV, max:maxV};

    const total = (dyn.max - dyn.min) || 1;
    const left = ((minV - dyn.min) / total) * 100;
    const right = ((maxV - dyn.min) / total) * 100;
    ui.fillEl.style.left = left + "%";
    ui.fillEl.style.width = Math.max(0, right - left) + "%";

    ui.labMin.textContent = String(minV);
    ui.labMax.textContent = String(maxV);
    ui.pill.textContent = `${minV} → ${maxV}`;
  }

  function createFacetUI(){
    facetBar.innerHTML = "";
    for(const spec of FACET_SPECS){
      const box = createFacetBox(spec);
      facetBar.appendChild(box);

      const searchEl = box.querySelector(`#search_${spec.id}`);
      const listEl = box.querySelector(`#list_${spec.id}`);
      const itemsEl = box.querySelector(`#items_${spec.id}`);
      const bannerEl = box.querySelector(`#banner_${spec.id}`);
      const clearBtn = box.querySelector(`#clear_${spec.id}`);

      facetUI[spec.id] = {searchEl, listEl, itemsEl, bannerEl, clearBtn};
      selected[spec.id] = new Set();

      clearBtn.addEventListener("click", ()=>{
        selected[spec.id].clear();
        render();
      });

      searchEl.addEventListener("input", ()=> drawFacetList(spec.id));
      listEl.addEventListener("scroll", ()=> updateSelectedBanner(spec.id));
    }
  }

  function createSliderUI(){
    sliderBar.innerHTML = "";
    for(const spec of NUM_SPECS){
      const wrap = createDualSlider(spec);
      sliderBar.appendChild(wrap);

      const minEl = wrap.querySelector(`#${spec.id}_min`);
      const maxEl = wrap.querySelector(`#${spec.id}_max`);
      const fillEl = wrap.querySelector(`#fill_${spec.id}`);
      const labMin = wrap.querySelector(`#lab_${spec.id}_min`);
      const labMax = wrap.querySelector(`#lab_${spec.id}_max`);
      const pill = wrap.querySelector(`#pill_${spec.id}`);

      sliderUI[spec.id] = {minEl, maxEl, fillEl, labMin, labMax, pill, spec};

      minEl.addEventListener("input", ()=> onNumericSliderAttempt(spec.id));
      maxEl.addEventListener("input", ()=> onNumericSliderAttempt(spec.id));
    }
  }

  function initSlidersFromData(){
    for(const spec of NUM_SPECS){
      const key = numFields[spec.id];
      const ui = sliderUI[spec.id];

      if(!key){
        ui.minEl.disabled = true;
        ui.maxEl.disabled = true;
        ui.pill.textContent = "— (champ introuvable)";
        ui.labMin.textContent = "—";
        ui.labMax.textContent = "—";
        continue;
      }

      let values = allRows
        .map(r => spec.isYear ? toYear(r[key]) : toInt(r[key]))
        .filter(v => Number.isFinite(v));

      if(values.length === 0){
        ui.minEl.disabled = true;
        ui.maxEl.disabled = true;
        ui.pill.textContent = "— (pas de valeurs)";
        ui.labMin.textContent = "—";
        ui.labMax.textContent = "—";
        continue;
      }

      let min = Math.floor(Math.min(...values));
      let max = Math.ceil(Math.max(...values));

      sliderAbs[spec.id] = {min, max, step:1, integer:true};
      sliderDyn[spec.id] = {min, max};

      ui.minEl.step = "1";
      ui.maxEl.step = "1";
      ui.minEl.value = String(min);
      ui.maxEl.value = String(max);

      updateDualUI(spec.id);
    }
  }

  function passesSearch(row){
    const q = norm(qEl.value);
    if(!q) return true;
    const text = Object.values(row).map(v=>String(v??"")).join(" ").toLowerCase();
    return text.includes(q);
  }

  function passesFacets(row){
    for(const spec of FACET_SPECS){
      const set = selected[spec.id];
      if(!set || set.size === 0) continue;
      const key = fields[spec.id];
      const v = normalizeFacetValue(spec.id, row[key]);
      if(!set.has(v)) return false;
    }
    return true;
  }

  function passesSliders(row){
    for(const spec of NUM_SPECS){
      const key = numFields[spec.id];
      const ui = sliderUI[spec.id];
      if(!key || !ui || ui.minEl.disabled) continue;

      const {min, max} = sliderVal[spec.id] || sliderAbs[spec.id];
      const val = spec.isYear ? toYear(row[key]) : toInt(row[key]);

      if(val === null){
        const abs = sliderAbs[spec.id];
        if(min !== abs.min || max !== abs.max) return false;
      } else {
        if(val < min || val > max) return false;
      }
    }
    return true;
  }

  function passesWater(row){
    if(!waterOnly) return true;
    return !!row.__water;
  }

  function passesAll(row){
    const n = String(row[fields.name] ?? "").trim();
    if(!n) return false;
    return passesSearch(row) && passesSliders(row) && passesFacets(row) && passesWater(row);
  }

  function baseRowsExcludingFacet(excludeFacetId){
    return allRows.filter(r=>{
      const n = String(r[fields.name] ?? "").trim();
      if(!n) return false;
      if(!passesSearch(r)) return false;
      if(!passesSliders(r)) return false;
      if(!passesWater(r)) return false;

      for(const spec of FACET_SPECS){
        if(spec.id === excludeFacetId) continue;
        const set = selected[spec.id];
        if(set && set.size){
          const key = fields[spec.id];
          const v = normalizeFacetValue(spec.id, r[key]);
          if(!set.has(v)) return false;
        }
      }
      return true;
    });
  }

  function computeFacetCounts(facetId){
    const key = fields[facetId];
    if(!key) return new Map();
    const base = baseRowsExcludingFacet(facetId);
    const m = new Map();
    for(const r of base){
      const v = normalizeFacetValue(facetId, r[key]);
      if(!v) continue;
      m.set(v, (m.get(v) || 0) + 1);
    }
    return m;
  }

  function computeWaterCount(){
    const base = allRows.filter(r=>{
      const n = String(r[fields.name] ?? "").trim();
      if(!n) return false;
      if(!passesSearch(r)) return false;
      if(!passesSliders(r)) return false;
      if(!passesFacets(r)) return false;
      return true;
    });
    let c = 0;
    for(const r of base) if(r.__water) c++;
    return c;
  }

  function stableRankOf(facetId, value){
    const m = facetStableRank[facetId];
    if(!m) return 1e9;
    return m.get(value) ?? 1e9;
  }

  function sortOptionsSelectedCountStable(facetId, options, counts, selectedSet){
    return options.slice().sort((a,b)=>{
      const sa = selectedSet.has(a) ? 1 : 0;
      const sb = selectedSet.has(b) ? 1 : 0;
      if(sb !== sa) return sb - sa;

      const ca = counts.get(a) || 0;
      const cb = counts.get(b) || 0;
      if(cb !== ca) return cb - ca;

      return stableRankOf(facetId, a) - stableRankOf(facetId, b);
    });
  }

  function updateSelectedBanner(facetId){
    const ui = facetUI[facetId];
    if(!ui) return;

    const selCount = selected[facetId]?.size || 0;
    if(selCount === 0){
      ui.bannerEl.style.display = "none";
      ui.bannerEl.textContent = "";
      return;
    }

    const wrap = ui.listEl;
    const top = wrap.scrollTop;
    const bottom = top + wrap.clientHeight;

    let visibleSelected = 0;
    const checkedRows = ui.itemsEl.querySelectorAll('input[type="checkbox"]:checked');

    checkedRows.forEach(cb=>{
      const row = cb.closest(".row");
      if(!row) return;
      const rTop = row.offsetTop;
      const rBottom = rTop + row.offsetHeight;
      const isVisible = (rBottom > top) && (rTop < bottom);
      if(isVisible) visibleSelected++;
    });

    if(visibleSelected === 0){
      ui.bannerEl.textContent = `${selCount} sélectionné${selCount>1?"s":""}`;
      ui.bannerEl.style.display = "block";
    } else {
      ui.bannerEl.style.display = "none";
      ui.bannerEl.textContent = "";
    }
  }

  function drawFacetList(facetId){
    const ui = facetUI[facetId];
    const key = fields[facetId];

    if(!key){
      ui.itemsEl.innerHTML = `<div class="empty">Champ introuvable</div>`;
      ui.searchEl.disabled = true;
      updateSelectedBanner(facetId);
      return;
    }

    const q = norm(ui.searchEl.value);
    const selectedSet = selected[facetId];
    const counts = computeFacetCounts(facetId);

    const baseOptions = facetMasterOptions[facetId] || [];
    const optSet = new Set([...baseOptions, ...Array.from(selectedSet)]);
    let options = Array.from(optSet).filter(v => v && !["-", "—", "n/a", "na", "unknown"].includes(norm(v)));

    options = sortOptionsSelectedCountStable(facetId, options, counts, selectedSet);
    const shown = options.filter(v => norm(v).includes(q));

    ui.itemsEl.innerHTML = shown.map(v=>{
      const c = counts.get(v) || 0;
      const disabled = (c === 0 && !selectedSet.has(v)) ? "disabled" : "";
      const checked = selectedSet.has(v) ? "checked" : "";
      return `
        <label class="row">
          <input type="checkbox" value="${esc(v)}" ${checked} ${disabled}>
          <span>${esc(v)}</span>
          <small>${c}</small>
        </label>
      `;
    }).join("") || `<div class="empty">Aucune option</div>`;

    ui.itemsEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const v = cb.value;
        if(cb.checked) selectedSet.add(v);
        else selectedSet.delete(v);
        render();
      });
    });

    updateSelectedBanner(facetId);
  }

  function updateAllFacetUIs(){
    for(const spec of FACET_SPECS) drawFacetList(spec.id);

    const c = computeWaterCount();
    waterCountEl.textContent = String(c);
    waterOnlyEl.disabled = (c === 0 && !waterOnly);

    for(const spec of FACET_SPECS) updateSelectedBanner(spec.id);
  }

  function getRange(id){
    const abs = sliderAbs[id];
    const ui = sliderUI[id];
    if(!abs || !ui || ui.minEl.disabled) return null;
    const {min, max} = sliderVal[id] || abs;
    return {min:Number(min), max:Number(max)};
  }

  function setDyn(id, dynMin, dynMax){
    const abs = sliderAbs[id];
    if(!abs) return;

    // IMPORTANT : les sliders "sièges" doivent toujours afficher min/max du JSON
    // => on ne leur applique pas de bornes dynamiques.
    const SEAT_IDS = new Set(["seatsPerRow","rowsPerCar","carsPerTrain"]);
    if(SEAT_IDS.has(id)){
      sliderDyn[id] = {min: abs.min, max: abs.max};
      return;
    }

    // Si contraintes invalides, on garde la plage actuelle (ou l'absolue).
    if(!Number.isFinite(dynMin) || !Number.isFinite(dynMax)){
      sliderDyn[id] = sliderDyn[id] || {min: abs.min, max: abs.max};
      return;
    }

    let dmin = Math.max(abs.min, Math.min(abs.max, Math.round(dynMin)));
    let dmax = Math.max(abs.min, Math.min(abs.max, Math.round(dynMax)));
    if(dmin > dmax){ const t=dmin; dmin=dmax; dmax=t; }

    // Anti-blocage : si la plage se réduit à une valeur, on l'élargit d'1 cran si possible
    if(dmin === dmax){
      const lo = Math.max(abs.min, dmin - 1);
      const hi = Math.min(abs.max, dmax + 1);
      if(lo < hi){ sliderDyn[id] = {min: lo, max: hi}; }
      else { sliderDyn[id] = {min: abs.min, max: abs.max}; }
      return;
    }

    sliderDyn[id] = {min: dmin, max: dmax};
  }

  function enforceSeatConstraints(){
    const SEAT_IDS = new Set(["seatsPerRow","rowsPerCar","carsPerTrain"]);

    // Clamp une sélection (min/max) dans une plage autorisée sans changer les bornes affichées.
    function clampSelection(id, allowedMin, allowedMax){
      const ui = sliderUI[id];
      const abs = sliderAbs[id];
      if(!ui || !abs || ui.minEl.disabled) return;

      // on garde l'affichage ABS (JSON)
      sliderDyn[id] = {min: abs.min, max: abs.max};

      const lo = Math.max(abs.min, Math.round(allowedMin));
      const hi = Math.min(abs.max, Math.round(allowedMax));
      if(!Number.isFinite(lo) || !Number.isFinite(hi) || lo > hi) return;

      let curMin = Math.round(Number(ui.minEl.value));
      let curMax = Math.round(Number(ui.maxEl.value));
      if(curMin > curMax){ const t=curMin; curMin=curMax; curMax=t; }

      curMin = Math.max(lo, Math.min(hi, curMin));
      curMax = Math.max(lo, Math.min(hi, curMax));
      if(curMin > curMax){ const t=curMin; curMin=curMax; curMax=t; }

      ui.minEl.value = String(curMin);
      ui.maxEl.value = String(curMax);
      updateDualUI(id);
    }

    const A = getRange("seatsPerRow");
    const B = getRange("rowsPerCar");
    const C = getRange("seatsPerCar");

    // A * B = C (cohérence voiture)
    if(A && B && C){
      const cmin = Math.max(1, Math.floor(C.min));
      const cmax = Math.max(1, Math.floor(C.max));
      const amin = Math.max(1, Math.floor(A.min));
      const amax = Math.max(1, Math.floor(A.max));
      const bmin = Math.max(1, Math.floor(B.min));
      const bmax = Math.max(1, Math.floor(B.max));

      // plages autorisées dérivées
      const A_lo = Math.ceil(cmin / Math.max(1, bmax));
      const A_hi = Math.floor(cmax / Math.max(1, bmin));
      const B_lo = Math.ceil(cmin / Math.max(1, amax));
      const B_hi = Math.floor(cmax / Math.max(1, amin));
      const C_lo = amin * bmin;
      const C_hi = amax * bmax;

      clampSelection("seatsPerRow", A_lo, A_hi);
      clampSelection("rowsPerCar", B_lo, B_hi);
      clampSelection("seatsPerCar", C_lo, C_hi);
    }

    

    // sécurité : on force dyn=abs pour ces sliders au cas où
    for(const id of SEAT_IDS){
      const abs = sliderAbs[id];
      if(abs) sliderDyn[id] = {min: abs.min, max: abs.max};
    }
  }

  function cardHTML(r, idx){
    const name = String(r[fields.name] ?? "").trim();
    const park = fields.park ? String(r[fields.park] ?? "").trim() : "";
    const y = numFields.year ? toYear(r[numFields.year]) : null;

    const rows = [];
    if(fields.maker) rows.push(["Fabricant", r[fields.maker]]);
    if(numFields.year) rows.push(["Ouverture", (y ?? "")]);

    const kv = rows
      .filter(([_,v]) => String(v ?? "").trim() !== "")
      .map(([k,v]) => `<div class="k">${esc(k)}</div><div class="v">${esc(v)}</div>`)
      .join("");

    return `
      <article class="card" tabindex="0" role="button" aria-label="Ouvrir les détails" data-idx="${idx}">
        <h2 class="title">${esc(name)}</h2>
        ${park ? `<p class="sub">${esc(park)}</p>` : ""}
        <div class="kv">${kv || `<div class="empty">Aucune info</div>`}</div>
      </article>
    `;
  }

  function updateArrowsState(){
    const n = lastRendered.length;
    if(n <= 1){ navLeftBtn.disabled = true; navRightBtn.disabled = true; return; }
    navLeftBtn.disabled = (currentIndex <= 0);
    navRightBtn.disabled = (currentIndex >= n - 1);
  }

  function openModalAtIndex(idx){
    const n = lastRendered.length;
    if(!n) return;
    currentIndex = Math.max(0, Math.min(n-1, idx));
    const row = lastRendered[currentIndex];

    const name = String(row[fields.name] ?? "").trim();
    const park  = fields.park ? String(row[fields.park] ?? "").trim() : "";

    modalTitleEl.textContent = name || "—";
    modalSubEl.textContent = park || "";

    const excludeKeys = new Set([fields.name, fields.park]);
    const pairs = Object.entries(row)
      .filter(([k,v]) => !excludeKeys.has(k) && !String(k).startsWith("__") && String(v ?? "").trim() !== "")
      .map(([k,v]) => {
        if(numFields.year && k === numFields.year){
          const yy = toYear(v);
          return [titleizeKey(k), (yy ?? v)];
        }
        return [titleizeKey(k), v];
      });

    modalGridEl.innerHTML = pairs.map(([k,v]) =>
      `<div class="modalK">${esc(k)}</div><div class="modalV">${esc(v)}</div>`
    ).join("") || `<div class="empty">Aucun détail.</div>`;

    updateArrowsState();
    modalOverlay.classList.add("open");
    modalOverlay.setAttribute("aria-hidden","false");
  }

  function closeModal(){
    modalOverlay.classList.remove("open");
    modalOverlay.setAttribute("aria-hidden","true");
    currentIndex = -1;
  }
  function prevModal(){ if(!navLeftBtn.disabled) openModalAtIndex(currentIndex - 1); }
  function nextModal(){ if(!navRightBtn.disabled) openModalAtIndex(currentIndex + 1); }

  navLeftBtn.addEventListener("click",(e)=>{e.stopPropagation();prevModal();});
  navRightBtn.addEventListener("click",(e)=>{e.stopPropagation();nextModal();});
  modalOverlay.addEventListener("click",(e)=>{ if(e.target===modalOverlay) closeModal(); });
  document.addEventListener("keydown",(e)=>{
    if(!modalOverlay.classList.contains("open")) return;
    if(e.key==="Escape"){ closeModal(); return; }
    if(e.key==="ArrowLeft"){ e.preventDefault(); prevModal(); return; }
    if(e.key==="ArrowRight"){ e.preventDefault(); nextModal(); return; }
  });

  // Numeric sliders must never lead to 0 results
  const lastGoodSliderValue = {}; // id -> {min,max}

  function countResults(){
    let c = 0;
    for(const r of allRows) if(passesAll(r)) c++;
    return c;
  }
  function snapshotSlider(id){
    const ui = sliderUI[id];
    if(!ui || ui.minEl.disabled) return null;
    return {min:Number(ui.minEl.value), max:Number(ui.maxEl.value)};
  }
  function restoreSlider(id, snap){
    if(!snap) return;
    const ui = sliderUI[id];
    if(!ui || ui.minEl.disabled) return;
    ui.minEl.value = String(Math.round(snap.min));
    ui.maxEl.value = String(Math.round(snap.max));
    updateDualUI(id);
  }
  function onNumericSliderAttempt(id){
    const ui = sliderUI[id];
    const abs = sliderAbs[id];
    if(!ui || !abs || ui.minEl.disabled) return;

    ui.minEl.value = String(Math.round(Number(ui.minEl.value)));
    ui.maxEl.value = String(Math.round(Number(ui.maxEl.value)));
    clampSwap(ui.minEl, ui.maxEl);

    updateDualUI(id);
    enforceSeatConstraints();

    const n = countResults();
    if(n === 0){
      restoreSlider(id, lastGoodSliderValue[id] || {min:abs.min, max:abs.max});
      enforceSeatConstraints();
      render();
      return;
    }
    lastGoodSliderValue[id] = snapshotSlider(id) || {min:abs.min, max:abs.max};
    render();
  }

  function render(){
    const fam1 = sortFamily(sortSel.value);
    for(const opt of Array.from(sort2Sel.options)){
      opt.disabled = (sortFamily(opt.value) === fam1);
    }
    if(sortFamily(sort2Sel.value) === fam1){
      const firstValid = Array.from(sort2Sel.options).find(o => !o.disabled);
      if(firstValid) sort2Sel.value = firstValid.value;
    }

    waterOnly = !!waterOnlyEl.checked;

    for(const spec of NUM_SPECS){
      const ui = sliderUI[spec.id];
      if(ui && sliderAbs[spec.id] && !ui.minEl.disabled) updateDualUI(spec.id);
    }
    enforceSeatConstraints();

    let filtered = allRows.filter(passesAll);
    filtered = sortRows(filtered, sortSel.value, sort2Sel.value, {year:numFields.year, park:fields.park});
    lastRendered = filtered;

    if(filtered.length === 0){
      grid.innerHTML = `<div class="empty">Aucun résultat.</div>`;
    } else {
      grid.innerHTML = filtered.map((r,i)=>cardHTML(r,i)).join("");
      grid.querySelectorAll(".card").forEach(card=>{
        const idx = Number(card.getAttribute("data-idx"));
        card.addEventListener("click", ()=> openModalAtIndex(idx));
        card.addEventListener("keydown",(e)=>{
          if(e.key==="Enter" || e.key===" "){
            e.preventDefault();
            openModalAtIndex(idx);
          }
        });
      });
    }

    updateAllFacetUIs();

    if(modalOverlay.classList.contains("open")){
      if(lastRendered.length === 0){ closeModal(); return; }
      if(currentIndex >= lastRendered.length) currentIndex = lastRendered.length - 1;
      updateArrowsState();
    }
  }

  try{
    const res = await fetch(dataUrl, { cache:"no-store" });
    if(!res.ok) throw new Error(`Fetch échoué (${res.status}) sur ${dataUrl}`);
    const rows = await res.json();
    if(!Array.isArray(rows)) throw new Error("Le JSON doit être un tableau.");
    if(rows.length === 0){ grid.innerHTML = `<div class="empty">Aucune donnée.</div>`; return; }

    const sample = rows[0];

    fields.name = pickField(sample, ["Nom","Name","Coaster","Attraction","Ride"]);
    if(!fields.name) throw new Error("Champ 'Nom de coaster' introuvable (Nom/Name/Coaster…).");

    for(const spec of FACET_SPECS) fields[spec.id] = pickField(sample, spec.candidates);
    for(const spec of NUM_SPECS) numFields[spec.id] = pickField(sample, spec.candidates);
    waterField = pickField(sample, WATER_CANDIDATES);

    // build facets & sliders
    createFacetUI();
    createSliderUI();

    // prepare data
    allRows = rows.map(r=>{
      const rr = {...r};
      rr.__water = parseWater(rr);
      computeDerivedSeats(rr);
      return rr;
    });

    // master options + stable rank
    for(const spec of FACET_SPECS){
      const key = fields[spec.id];
      if(!key){ facetMasterOptions[spec.id] = []; facetStableRank[spec.id] = new Map(); continue; }

      const opts = allRows
        .map(r => normalizeFacetValue(spec.id, r[key]))
        .filter(v => v && !["-", "—", "n/a", "na", "unknown"].includes(norm(v)));

      const uniq = Array.from(new Set(opts));

      const globalCounts = new Map();
      uniq.forEach(v => globalCounts.set(v, 0));
      for(const r of allRows){
        const v = normalizeFacetValue(spec.id, r[key]);
        if(!v || !globalCounts.has(v)) continue;
        globalCounts.set(v, (globalCounts.get(v)||0) + 1);
      }

      const orderedDefault = uniq.slice().sort((a,b)=>{
        const ca = globalCounts.get(a) || 0;
        const cb = globalCounts.get(b) || 0;
        if(cb !== ca) return cb - ca;
        return String(a).localeCompare(String(b), "fr");
      });

      facetMasterOptions[spec.id] = orderedDefault;

      const rankMap = new Map();
      orderedDefault.forEach((v,i)=>rankMap.set(v,i));
      facetStableRank[spec.id] = rankMap;
    }

    // init sliders
    initSlidersFromData();
    enforceSeatConstraints();

    // full span at load + lastGood = full span
    for(const spec of NUM_SPECS){
      const abs = sliderAbs[spec.id];
      const ui = sliderUI[spec.id];
      if(!abs || !ui || ui.minEl.disabled) continue;
      sliderDyn[spec.id] = {min:abs.min, max:abs.max};
      ui.minEl.value = String(abs.min);
      ui.maxEl.value = String(abs.max);
      updateDualUI(spec.id);
      lastGoodSliderValue[spec.id] = {min:abs.min, max:abs.max};
    }
    enforceSeatConstraints();

    qEl.addEventListener("input", render);

    let prevPrimary = sortSel.value;
    sortSel.addEventListener("change", ()=>{
      const newPrimary = sortSel.value;
      if(sortFamily(newPrimary) === sortFamily(sort2Sel.value)){
        sort2Sel.value = prevPrimary;
      }
      prevPrimary = newPrimary;
      render();
    });
    sort2Sel.addEventListener("change", render);

    waterOnlyEl.addEventListener("change", render);

    $("clear").addEventListener("click", ()=>{
      qEl.value = "";
      waterOnlyEl.checked = false;

      for(const spec of FACET_SPECS){
        selected[spec.id].clear();
        facetUI[spec.id].searchEl.value = "";
        facetUI[spec.id].listEl.scrollTop = 0;
      }

      for(const spec of NUM_SPECS){
        const abs = sliderAbs[spec.id];
        const ui = sliderUI[spec.id];
        if(!abs || !ui || ui.minEl.disabled) continue;
        sliderDyn[spec.id] = {min:abs.min, max:abs.max};
        ui.minEl.value = String(abs.min);
        ui.maxEl.value = String(abs.max);
        updateDualUI(spec.id);
        lastGoodSliderValue[spec.id] = {min:abs.min, max:abs.max};
      }
      enforceSeatConstraints();

      sortSel.value = "park_asc";
      sort2Sel.value = "year_asc";
      prevPrimary = sortSel.value;

      closeModal();
      render();
    });

    render();

  } catch(e){
    console.error(e);
    showError(
      "Erreur:\n" + (e?.message ?? String(e)) +
      "\n\nÀ vérifier:\n- data/coasters_clean.json existe\n- JSON valide (tableau)\n- GitHub Pages (pas file://)"
    );
  }
})();
</script>
</body>
</html>
